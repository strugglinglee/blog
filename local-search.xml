<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vue3.0发布后的一点总结</title>
    <link href="/2022/08/19/vue/vue3.x%20Reactive()%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/08/19/vue/vue3.x%20Reactive()%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一次我们讨论了<a href="https://juejin.cn/post/7125379985946181668">Vue2.x的响应式原理</a>。<br>主要的步骤是遍历对象每个property，通过Object.defineProperty()方法进行数据劫持，给每一个property加上getter/setter，getter进行依赖收集，setter中通知订阅者执行副作用。</p><h3 id="Vue2-x-Object-defineProperty-的不足"><a href="#Vue2-x-Object-defineProperty-的不足" class="headerlink" title="Vue2.x Object.defineProperty()的不足"></a>Vue2.x Object.defineProperty()的不足</h3><p>主要有以下：</p><ol><li><p> 无法检测属性的添加和删除；</p></li><li><p> 无法检测数组索引和长度的变更</p></li><li><p> 不支持 Map、Set、WeakMap 和 WeakSet。</p></li></ol><h3 id="为什么vue3-x要使用Proxy进行数据劫持？"><a href="#为什么vue3-x要使用Proxy进行数据劫持？" class="headerlink" title="为什么vue3.x要使用Proxy进行数据劫持？"></a>为什么vue3.x要使用Proxy进行数据劫持？</h3><ol><li><p> Proxy 可以直接监听对象和数组的变化，有多达 13 种拦截方法，这是 Object.defineProperty 不具备的；</p></li><li><p> Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</p></li><li><p> Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</p></li></ol><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><blockquote><p>本篇文章主要介绍vue3.0响应式原理，涉及一些es6+的知识，在此做一些简单的补充，想深入了解的知识可以再看完本篇文章之后再继续研究。</p><ol><li> <a href="https://es6.ruanyifeng.com/#docs/reflect">https://es6.ruanyifeng.com/#docs/reflect</a></li><li> <a href="https://es6.ruanyifeng.com/#docs/proxy">https://es6.ruanyifeng.com/#docs/proxy</a></li><li> <a href="https://es6.ruanyifeng.com/#docs/set-map">https://es6.ruanyifeng.com/#docs/set-map</a></li></ol></blockquote><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>简单来说，<code>Reflect</code>就是<code>Object</code>的未来形式。</p><p>之前将在<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// old</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">target</span>, <span class="hljs-params">property</span>, <span class="hljs-params">attributes</span>)</span>;<br><span class="hljs-comment">// new</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>define<span class="hljs-constructor">Property(<span class="hljs-params">target</span>, <span class="hljs-params">property</span>, <span class="hljs-params">attributes</span>)</span><br></code></pre></td></tr></table></figure><h4 id="Reflect-get-target-name-receiver"><a href="#Reflect-get-target-name-receiver" class="headerlink" title="Reflect.get(target, name, receiver)"></a>Reflect.get(target, name, receiver)</h4><p>获取属性值的方法，target表示对象，name是访问的属性名。</p><blockquote><p>receiver中接收对象，访问<code>proxy</code>对象会优先访问receiver，以下的receiver均为此概念。</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> myObject = &#123;<br>  foo: <span class="hljs-number">1</span><br>&#125;<br>Reflect.<span class="hljs-keyword">get</span>(myObject, <span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="Reflect-set-target-name-value-receiver"><a href="#Reflect-set-target-name-value-receiver" class="headerlink" title="Reflect.set(target, name, value, receiver)"></a>Reflect.set(target, name, value, receiver)</h4><p>设置属性值的方法，target表示对象，name是要设置的属性名，value是要设置的值。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">var myObject = &#123;<br>  foo: <span class="hljs-number">1</span><br>&#125;<br>myObject.foo <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><br>Reflect.set(myObject, <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">2</span>);<br>myObject.foo <span class="hljs-regexp">//</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><p>比如，访问以下obj中的某个属性，无论存不存在，都会触发get函数；如果设置以下obj的某个属性，就会触发set函数。</p><blockquote><p><strong>注意</strong>：proxy只能代理一层，如果某个属性值仍然是对象，这个对象内部的改变是无法监测到的。</p></blockquote><blockquote><p>target:代理的对象、 propKey：访问的属性名、value：属性值</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">var obj = <span class="hljs-keyword">new</span> Proxy(&#123;&#125;, &#123;<br>    get: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(target, propKey, receiver) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Reflect.get(target,</span> propKey, receiver);<br>         &#125;,<br>    set: <span class="hljs-keyword">function</span> <span class="hljs-title"></span>(target, propKey, value, receiver) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">Reflect.set(target,</span> propKey, value, receiver);<br>         &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><p><code>WeakMap</code>结构与<code>Map</code>结构类似，也是用于生成键值对的集合。</p><h4 id="WeakMap与Map的区别"><a href="#WeakMap与Map的区别" class="headerlink" title="WeakMap与Map的区别"></a><code>WeakMap</code>与<code>Map</code>的区别</h4><ol><li> <code>WeakMap</code>只接受对象作为键名（<code>null</code>除外）</li></ol><!----><ol start="2"><li> 不接受其他类型的值作为键名。</li></ol><h4 id="使用WeakMap的优点"><a href="#使用WeakMap的优点" class="headerlink" title="使用WeakMap的优点"></a>使用WeakMap的优点</h4><p><code>WeakMap</code>的专用场合就是，它的键所对应的对象，可能会在将来消失。<code>WeakMap</code>结构有助于防止内存泄漏。</p><h2 id="简单理解：什么是响应式？"><a href="#简单理解：什么是响应式？" class="headerlink" title="简单理解：什么是响应式？"></a>简单理解：什么是响应式？</h2><blockquote><p>以下例子来源于<a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#what-is-reactivity">vue官网-深入响应式系统</a></p></blockquote><p>在JS中，我们无法简单地通过表达式来创建一个值与另外的值的关联</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> A<span class="hljs-number">0</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">let</span> A<span class="hljs-number">1</span> = <span class="hljs-number">2</span><br><span class="hljs-attribute">let</span> A<span class="hljs-number">2</span> = A<span class="hljs-number">0</span> + A<span class="hljs-number">1</span><br><br><span class="hljs-attribute">console</span>.log(A<span class="hljs-number">2</span>) // <span class="hljs-number">3</span><br><br><span class="hljs-attribute">A0</span> = <span class="hljs-number">2</span><br><span class="hljs-attribute">console</span>.log(A<span class="hljs-number">2</span>) // 仍然是 <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>当一个值依赖的值变化时，我们需要通过一个update方法来更新这个值</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">let</span> <span class="hljs-built_in">A2</span><br><span class="hljs-symbol">function</span> update() &#123;<br>  <span class="hljs-built_in">A2</span> = A0 + <span class="hljs-built_in">A1</span><br>&#125;<br><span class="hljs-comment">// 手动触发</span><br><span class="hljs-symbol">A0</span> = <span class="hljs-number">2</span> <br><span class="hljs-symbol">update</span>()<br></code></pre></td></tr></table></figure><p>这里我们刚好通过这个例子解释下我们常说的一些名词：</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a><strong>副作用</strong></h3><p>update函数里面执行的代码就是副作用，或者更可以简称为作用，其可以改变程序中的状态。</p><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a><strong>依赖</strong></h3><p>这个副作用改变程序里的状态是依赖于A0或A1的改变，所以A0和A1就是这个副作用的依赖</p><h3 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a><strong>订阅者</strong></h3><p>A2订阅了A0和A1的改变，在这里就A2相当于是一个订阅者</p><h2 id="reactive建立响应式全过程"><a href="#reactive建立响应式全过程" class="headerlink" title="reactive建立响应式全过程"></a>reactive建立响应式全过程</h2><p>以上的例子，当依赖改变的时候我们需要手动触发副作用，当依赖渐渐变多或者更多的改变时我们将难以进行追踪，所以在vue中，我们需要一种响应性系统可以自动跟踪依赖关系。</p><p>首先，我们来了解下reactive是如何建立响应式系统的。</p><h3 id="通过reactive建立proxy代理"><a href="#通过reactive建立proxy代理" class="headerlink" title="通过reactive建立proxy代理"></a>通过reactive建立proxy代理</h3><p>以下写法是我们vue3.x中的常见写法，我们会在reactive函数中传入一个对象，接下来我们需要探索在这个函数中发生了什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 第一步：通过reactive建立proxy代理</span><br><span class="hljs-keyword">const</span> state = reactive(&#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="proxy代理"><a href="#proxy代理" class="headerlink" title="proxy代理"></a>proxy代理</h3><h4 id="get："><a href="#get：" class="headerlink" title="get："></a>get：</h4><p>当访问对象中的某个属性的时候，会触发track函数，这个track函数是用来收集依赖的，也就是收集被访问的key相关的副作用的，这个函数后面再深入介绍。</p><h4 id="set："><a href="#set：" class="headerlink" title="set："></a>set：</h4><p>当对象中某个属性值发生变化的时候，就会触发trigger函数，这个函数主要是用来触发每个依赖对应副作用的执行，我们也会在后面深入介绍这个函数。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> reactive = (<span class="hljs-keyword">target</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">handler</span> = &#123;<br>    get(<span class="hljs-keyword">target</span>, key, receiver) &#123;<br>      <span class="hljs-comment">// 相当于 target[key]</span><br>      <span class="hljs-keyword">const</span> result = Reflect.get(<span class="hljs-keyword">target</span>, key, receiver);<br>      <span class="hljs-comment">// 收集依赖（通过key来收集依赖对应的副作用）</span><br>      track(<span class="hljs-keyword">target</span>, key);<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;,<br>    set(<span class="hljs-keyword">target</span>, key, value, receiver) &#123;<br>      <span class="hljs-keyword">const</span> oldValue = <span class="hljs-keyword">target</span>[key];<br>      <span class="hljs-comment">// target[key]=value</span><br>      <span class="hljs-keyword">const</span> result = Reflect.set(<span class="hljs-keyword">target</span>, key, value, receiver);<br>      <span class="hljs-keyword">if</span> (oldValue != result) &#123;<br>        <span class="hljs-comment">// 触发每个依赖对应的副作用的执行</span><br>        trigger(<span class="hljs-keyword">target</span>, key);<br>      &#125;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">handler</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Track"><a href="#Track" class="headerlink" title="Track"></a>Track</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>音译为跟踪，追踪。我们可以理解为一个追踪依赖相关的所有副作用集合的过程。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff19a33c439640ceaea2bdfc4f985db6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>我们可以通过上图看到我们收集effect的中还要根据对象，以及对象的属性来进行分类，并不是简单的一层收集，这样收集的好处是，后期某个属性值发生改变的时候，我们就可以根据这个层级一级一级的找出它对应的副作用了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6566c8e9622349cc9a9c3c6e00ab7e7f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><h5 id="Effect"><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h5><p>首先我们需要有一个effect方法来书写副作用，也就类似于我们前文提到的update函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; reactive, effect &#125; = <span class="hljs-built_in">require</span> ( <span class="hljs-string">&#x27;./reactivity.js&#x27;</span> )<br><br><span class="hljs-keyword">const</span> state = reactive (&#123;  <span class="hljs-attr">a</span> : <span class="hljs-number">1</span> ,  <span class="hljs-attr">b</span> : <span class="hljs-number">2</span>  &#125;)<br><br><span class="hljs-keyword">let</span> c = <span class="hljs-number">0</span>  <br>effect(<span class="hljs-function">() =&gt;</span> &#123;<br>    c = state.a + state.b <br>&#125;)<br></code></pre></td></tr></table></figure><p>接下来我们一起看看触发effect函数的时候究竟发生了什么。</p><p>首先，你访问了state.a和 state.b，自然就会触发get中的track函数进行依赖追踪。</p><p>过程中，第一步就是检测此时有没有正在执行的副作用，也就是activeEffect。</p><blockquote><p><strong>这里稍微解释下activeEffect存在的必要性：</strong><br>你要知道不管是在effect方法中，还是在effect外访问对象属性都会触发track函数。<br>因为我们是收集依赖对应的副作用，activeEffect是为了确认是在effect方法中访问对象属性。</p></blockquote><p>剩下的步骤可以对照原理的图一一对应，就是收集以对象为维度，收集依赖对应的副作用的过程。</p><h5 id="track主要代码"><a href="#track主要代码" class="headerlink" title="track主要代码"></a>track主要代码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> track = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">let</span> depsMap = targetMap.get(target);<br>    <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>        targetMap.set(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()));<br>    &#125;<br>    <span class="hljs-keyword">let</span> dep = depsMap.get(key);<br>    <span class="hljs-keyword">if</span> (!dep) &#123;<br>        depsMap.set(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()));<br>    &#125;<br>    <span class="hljs-comment">// 添加 activeEffect 依赖</span><br>    dep.add(activeEffect);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;targetMap&#x27;</span>,targetMap)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="activeEffect"><a href="#activeEffect" class="headerlink" title="activeEffect"></a>activeEffect</h5><p>前文已经说明了activeEffect存在的必要性，这个过程很巧妙，在这里我稍微梳理下流程。</p><p>首先我们都知道js是单线程的脚本语言，我们调用effect方法时会按照以下步骤执行：</p><ol><li> 将副作用赋值给 activeEffect</li><li> 执行 activeEffect，这个过程中如果访问了对象属性，就会触发track进行依赖收集</li><li> 重置 activeEffect为null</li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236e5b929d454be683076315d6e408c6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// reactivity.js</span><br><span class="hljs-comment">// 存储正在执行的副作用</span><br><span class="hljs-keyword">let</span> activeEffect = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 引入 activeEffect 变量</span><br><br><span class="hljs-keyword">const</span> effect = <span class="hljs-function"><span class="hljs-params">eff</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 1. 将副作用赋值给 activeEffect</span><br>    activeEffect = eff;<br>    <span class="hljs-comment">// 2. 执行 activeEffect</span><br>    activeEffect();<br>    <span class="hljs-comment">// 3. 重置 activeEffect</span><br>    activeEffect = <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>实际上就是递归遍历targetMap的过程，根据target和key找出改变的属性有无对应的副作用，如果有的话就执行。</p><ol><li><p> target对应的属性变化，触发set中的trigger</p></li><li><p> 寻找targetMap有无target对应的depsMap</p></li><li><p> 寻找depsMap中有无key对应的dep</p></li><li><p> 如果有dep,就依次执行dep中存储的副作用</p></li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d422a3c777547cfa2b46bda2ae0ed11~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> trigger = <span class="hljs-function">(<span class="hljs-params">target, key</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> depsMap = targetMap.get(target);<br>    <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> dep = depsMap.get(key);<br>    <span class="hljs-keyword">if</span> (dep) &#123;<br>        dep.forEach(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> effect());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为proxy只能代理一层，所以如果属性值对应的依旧是一个对象，那需要把这个对象也包装为一个响应式对象。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">const</span> reactive = (<span class="hljs-keyword">target</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">handler</span> = &#123;<br>        get(<span class="hljs-keyword">target</span>, key, receiver) &#123;<br>            <span class="hljs-keyword">const</span> result = Reflect.get(<span class="hljs-keyword">target</span>, key, receiver);<br>            <span class="hljs-comment">// 收集依赖对应的副作用</span><br>            track(<span class="hljs-keyword">target</span>, key);<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 因为proxy只能代理一层，所以</span><br><span class="hljs-comment">             * 如果属性值对应的依旧是一个对象，那需要把这个对象也包装为一个响应式对象</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (isObject(result)) <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">reactive</span><span class="hljs-params">(result)</span></span>;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;,<br>        set(<span class="hljs-keyword">target</span>, key, value, receiver) &#123;<br>            <span class="hljs-keyword">const</span> result = Reflect.set(<span class="hljs-keyword">target</span>, key, value, receiver);<br>            <span class="hljs-comment">// 触发依赖对应副作用</span><br>            trigger(<span class="hljs-keyword">target</span>, key);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Proxy(<span class="hljs-keyword">target</span>, <span class="hljs-keyword">handler</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = reactive(&#123;<br>    <span class="hljs-attr">e</span>: &#123;<br>        <span class="hljs-attr">f</span>: <span class="hljs-number">1</span><br>    &#125;<br>&#125;)<br>effect(<span class="hljs-function">() =&gt;</span> &#123;<br>    c = state.e.f<br>    <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">//执行两次 第一次1 第二次2</span><br>&#125;)<br>state.e.f = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h3 id="线上地址"><a href="#线上地址" class="headerlink" title="线上地址"></a>线上地址</h3><p>全文涉及的代码都上传到了git仓库，欢迎fork、star，提issue~</p><p><a href="https://github.com/strugglinglee/reactivity.git">https://github.com/strugglinglee/reactivity.git</a></p><h3 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h3><p>代码调试可以让我们更清楚的了解其中的过程，如有需要请参考这篇文章。</p><p><a href="https://juejin.cn/post/7030584939020042254">https://juejin.cn/post/7030584939020042254</a></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>看过很多文章，包括自己写过的水文笔记，有的时候看完还不如不看，对知识的了解更加模糊，赶紧关闭寻找下一篇。</p><p>自己很佩服的一位大佬就是阮一峰，他写的技术文给我帮助很大，由浅入深，让你很容易的就接受了新的知识，换句话说，就是在写你我都能够看得懂的文章。</p><p>文章写出来就是给人看的，好的文章是值得反复观看推敲的，所以近期定下自己的目标：输出我们都能看得懂的文章，把艰涩的文字变成跳动的语言。</p><p>创作不易，如果你觉得不错，欢迎点赞收藏，有什么问题也可以评论交流讨论。最后，非常感谢你的阅读！</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li> <a href="https://juejin.cn/post/6977513378256257031">探索 Vue3 响应式原理</a></li><li> <a href="https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#what-is-reactivity">vue官网-深入响应式系统</a></li><li><a href="https://juejin.cn/post/7125379985946181668">Vue响应式原理探究之“发布-订阅”模式</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>vue3源码学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3.0</tag>
      
      <tag>响应式原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端适配方案详解</title>
    <link href="/2022/08/15/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/08/15/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要做适配"><a href="#为什么要做适配" class="headerlink" title="为什么要做适配"></a>为什么要做适配</h2><p>因为视口、逻辑像素、分辨率这些变量的不同，在每个设备展示都不一样，需要一种方案来统一。</p><h3 id="物理像素"><a href="#物理像素" class="headerlink" title="物理像素"></a>物理像素</h3><p>也就是分辨率，一个物理像素是显示器上的最小的物理显示单元，所以分辨率越高，屏幕可展示的像素点越多，也就更清晰。</p><h3 id="逻辑像素"><a href="#逻辑像素" class="headerlink" title="逻辑像素"></a>逻辑像素</h3><p>也叫设备独立像素，可以认为是计算机坐标系统中的一个点，这一个点代表可以由程序使用的虚拟像素（css像素），然后由相关系统转换为物理像素。</p><h3 id="设备像素比-Device-pixel-ratio"><a href="#设备像素比-Device-pixel-ratio" class="headerlink" title="设备像素比(Device pixel ratio)"></a>设备像素比(Device pixel ratio)</h3><p>简称dpr，定义了物理像素和设备独立像素的对应关系</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">设备像素比 </span>=<span class="hljs-string"> 物理像素 / 逻辑像素</span><br></code></pre></td></tr></table></figure><h3 id="移动端1px问题"><a href="#移动端1px问题" class="headerlink" title="移动端1px问题"></a>移动端1px问题</h3><p>一般设计稿都是以750px宽度为基准，当设计师给出1px的数据的时候，对于视觉视口宽度为375px的手机，dpr如果为2，逻辑像素应该是0.5px，但移动端css最低只支持显示1px大小，这时候边框宽度就会是设计稿而言就会略粗一点。</p><h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><p>通常与浏览器窗口相同，但不包括浏览器的UI、菜单栏</p><ul><li>  文档的 <code>Element.clientWidth</code> 是指一个文档使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag#screen_density">CSS pixels</a> 单位表示的内部宽度，<strong>包括其 padding（不包括 border、margin 或垂直滚动条）</strong> 。这就是视口的宽度。–<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Viewport_concepts">《MND文档》</a></li></ul><h4 id="移动设备的视口的默认值为-980px"><a href="#移动设备的视口的默认值为-980px" class="headerlink" title="移动设备的视口的默认值为 980px"></a>移动设备的视口的默认值为 980px</h4><p>对于各种不同形状，不同设备像素比移动设备，其浏览器的视口（窗口中显示网页信息的区域）不一定与渲染页面大小相同。移动设备的视口的默认值为 980px，一般情况下都要比这些设备的屏幕尺寸要大。</p><p>为了让页面能够全部展示，这些浏览器在渲染时会对页面进行缩放。比如在一个宽 375px 的移动设备显示一个视觉视口宽为 980px 的页面，移动设备浏览器会对这个页面进行缩放直至其视觉视口宽度为 375px（具体取决于浏览器实现）。但直接缩放页面会导致页面字体变小，使得缩放后的页面显示效果都不会很理想。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d36d165f060491599ad1882efc5d434~tplv-k3u1fbpfcp-zoom-1.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20c656c6c7cc407abc60bfc894c295e8~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="布局视口、视觉视口、理想视口"><a href="#布局视口、视觉视口、理想视口" class="headerlink" title="布局视口、视觉视口、理想视口"></a>布局视口、视觉视口、理想视口</h4><p>在移动端，为了让页面展示更多的内容，视口有以下区分：</p><ul><li>  <strong>布局视口</strong>：移动设备视口的默认值是980px，比屏幕宽度大，目的是能够展示更多那些PC端的网页内容；</li><li>  <strong>视觉视口</strong>：屏幕宽度；</li><li>  <strong>理想视口</strong>：布局视口=视觉视口；</li></ul><p>上文说到移动设备视口的默认值是980px，由于视觉视口只有屏幕宽度，比如375px，那么我们看到的页面就会有一定的缩放，这样的效果是不太好的。</p><p>那么如何创建一个理想视口，让移动端浏览器使用屏幕宽度作为视口替换默认的 980px 宽度视口呢？</p><p>我们可以在 HTML 的头部添加以下标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里 <code>width</code> 属性指的是视口宽度，现在视口的宽度被设置为了设备的屏幕宽度，即文档视口宽度大小与设备宽度大小 100% 对应（转换为 CSS 像素值相同）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcd1d466951f48ba9d0cfd586ef71e88~tplv-k3u1fbpfcp-zoom-1.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba5a79982a5945cd9e1e6f4d428b9c02~tplv-k3u1fbpfcp-zoom-1.image"></p><p>其他属性释义：</p><ul><li><p>  <code>initial-scale</code>(初始缩放比例)</p></li><li><p>  <code>maximum-scale</code>(最大缩放比例)</p></li><li><p>  <code>minimum-scale</code>(最小缩放比例)</p></li><li><p>  <code>user-scalable</code>(是否允许用户进行缩放操作)</p></li></ul><p>这些属性的默认值已经很好了，开发时可以忽略掉这些属性。</p><h2 id="移动端适配方案"><a href="#移动端适配方案" class="headerlink" title="移动端适配方案"></a>移动端适配方案</h2><ol><li> 弹性盒模型布局（前端必备技能，略）</li><li> 流式布局（百分比布局）</li><li> rem布局</li><li> vw/vh</li><li> 响应式布局（媒体查询）</li></ol><h3 id="常用适配方案"><a href="#常用适配方案" class="headerlink" title="常用适配方案"></a>常用适配方案</h3><ol><li>rem &amp; vw</li><li>rem &amp; 媒体查询</li></ol><h2 id="一、rem适配"><a href="#一、rem适配" class="headerlink" title="一、rem适配"></a>一、rem适配</h2><blockquote><p>rem这个单位代表根元素（通常为<code>&lt;html&gt;</code> 元素）的 <code>font-size</code> 大小。当用在根元素的 <code>font-size</code> 上面时，它代表了它的初始值。–《MDN》</p></blockquote><h3 id="原理与实现"><a href="#原理与实现" class="headerlink" title="原理与实现"></a>原理与实现</h3><p>通俗来讲，rem是一个相对单位，根元素的font-size的大小为一个rem单位。</p><p>rem适配指的是，通过设置根元素的font-size的大小，后续子元素就可以使用rem为单位，实际<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Viewport_meta_tag#screen_density">CSS pixels</a> 单位需要在这个基础上乘以根元素的font-size。</p><p>eg. 设置根元素font-size为16px，设置其中一个子元素宽度为20rem，那这个子元素实际的宽度为20*16px=320px</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3c56d1509a240cb9405911756090d79~tplv-k3u1fbpfcp-zoom-1.image"></p><p>一般移动端设计稿会以750px为基准，但由于每个移动设备的宽度不同，我们需要去按照这个基准去按比例适配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 设计稿宽度</span><br><span class="hljs-keyword">const</span> WIDTH = <span class="hljs-number">750</span><br><br><span class="hljs-comment">// 设计稿中某元素的宽度</span><br><span class="hljs-keyword">const</span> uiWidth = 100px <br><br><span class="hljs-comment">// 屏幕宽度与设计稿宽度比例</span><br><span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">document</span>.documentElement.clientWidth / WIDTH<br><span class="hljs-comment">// 屏幕中的实际宽度</span><br><span class="hljs-keyword">const</span> realWidth = uiWidth * scale <br><span class="hljs-comment">// 以375px屏幕宽为例</span><br><span class="hljs-comment">// realWidth = 100 * （375/750）= 50px</span><br></code></pre></td></tr></table></figure><p>按照这个思路，为了计算方便，我们可以使用rem来进行适配，将以上代码可以改写为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 根据屏幕宽度与设计稿宽度比例 设置rem单位长度</span><br><span class="hljs-keyword">const</span> htmlFontSize = (<span class="hljs-built_in">document</span>.documentElement.clientWidth / WIDTH ) * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;px&#x27;</span><br><span class="hljs-comment">// (375/750)*100= 50px</span><br><br><span class="hljs-comment">// 实际大小其实就是</span><br><span class="hljs-keyword">let</span> realWidth = uiWidth * htmlFontSize / <span class="hljs-number">100</span><br><span class="hljs-comment">// 100*50/100 = 50px</span><br><br><span class="hljs-comment">// 得出最终公式</span><br>realWidth = uiWidth / <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;rem&#x27;</span><br></code></pre></td></tr></table></figure><p>最后，需要监听页面大小改变，rem适配配置就完成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRem</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> WIDTH = <span class="hljs-number">750</span><br>    <span class="hljs-comment">// 当前页面宽度相对于 750 宽的缩放比例，可根据自己需要修改</span><br>    <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">document</span>.documentElement.clientWidth / WIDTH;<br>    <span class="hljs-built_in">document</span>.documentElement.style.fontSize = scale + <span class="hljs-string">&#x27;px&#x27;</span>;<br>&#125;<br>setRem();<br><span class="hljs-built_in">window</span>.onresize = setRem;<br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>兼容性高，可以通过动态设置根元素的font-size来适配不同的屏幕</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要使用js，更适用于手机端，在大屏设备（如ipad）上，元素的尺寸大，可展示的内容不足。</li><li>移动端1px问题需要另外处理</li></ul><h3 id="针对大屏改进方案-flexible-方案"><a href="#针对大屏改进方案-flexible-方案" class="headerlink" title="针对大屏改进方案( flexible 方案)"></a>针对大屏改进方案( flexible 方案)</h3><p>动态设置 rem 实现在不同尺寸的设备上界面展示效果一致</p><ol><li> 限制 rem 的最大值</li><li> 通过媒体查询限制内容最大宽度</li></ol><h3 id="插件使用postcss-pxtorem"><a href="#插件使用postcss-pxtorem" class="headerlink" title="插件使用postcss-pxtorem"></a>插件使用postcss-pxtorem</h3><blockquote><p><a href="https://www.npmjs.com/package/postcss-pxtorem">postcss-pxtorem传送门</a></p></blockquote><ol><li> 下载postcss postcss-pxtorem</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install postcss postcss-pxtorem --save-dev<br></code></pre></td></tr></table></figure><ol start="2"><li> js动态设置</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">const</span> baseSize = <span class="hljs-number">37.5</span>  <span class="hljs-comment">//跟配置中rootValue的值是一致的     </span></span><br><span class="javascript">    <span class="hljs-comment">// 设置 rem 函数     </span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRem</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">// 当前页面宽度相对于 375 宽的缩放比例，可根据自己需要修改。         </span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> scale = <span class="hljs-built_in">document</span> .documentElement.clientWidth / <span class="hljs-number">375</span>         </span><br><span class="javascript">        <span class="hljs-comment">// 设置页面根节点字体大小 最高为两倍图 即设计稿为750     </span></span><br><span class="javascript">        <span class="hljs-built_in">document</span>.documentElement.style.fontSize = (baseSize * <span class="hljs-built_in">Math</span>.min(scale, <span class="hljs-number">2</span>)) + <span class="hljs-string">&#x27;px&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-comment">// 初始化     </span></span><br><span class="javascript">    setRem()</span><br><span class="javascript">    <span class="hljs-comment">// 改变窗口大小时重新设置 rem     </span></span><br><span class="javascript">    <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        setRem()</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li> 写好index.css之后执行以下脚本，可以编译出一个已经进行rem转换的文件main-rem.css<blockquote><p>通过options配置或者通过1Px或者PX为单位来解决移动端1px的问题，<a href="https://segmentfault.com/a/1190000010947054">参考文章</a></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span> ( <span class="hljs-string">&#x27;fs&#x27;</span> ) ;<br><span class="hljs-keyword">var</span> postcss = <span class="hljs-built_in">require</span> ( <span class="hljs-string">&#x27;postcss&#x27;</span> ) ;<br><span class="hljs-keyword">var</span> pxtorem = <span class="hljs-built_in">require</span> ( <span class="hljs-string">&#x27;postcss-pxtorem&#x27;</span> ) ;<br><span class="hljs-keyword">var</span> css = fs.readFileSync( <span class="hljs-string">&#x27;index.css&#x27;</span> , <span class="hljs-string">&#x27;utf8&#x27;</span> ) ;<br><span class="hljs-keyword">var</span> options = &#123;  <span class="hljs-attr">rootValue</span> : <span class="hljs-number">37.5</span> ,  <span class="hljs-attr">propList</span> : [ <span class="hljs-string">&#x27;*&#x27;</span> ] &#125; ;<br><span class="hljs-keyword">var</span> processedCss = postcss(pxtorem( options )).process( css ).css;<br><br>fs.writeFile(<span class="hljs-string">&#x27;main-rem.css&#x27;</span>, processedCss, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (err) &#123;<br>    <span class="hljs-keyword">throw</span> err;<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Rem file written.&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*index.css*/</span><br><span class="hljs-selector-tag">body</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-selector-id">#app</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">375px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: brown;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f36bf5d73634ce3997a4feb2291e337~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="二、vw适配（推荐）"><a href="#二、vw适配（推荐）" class="headerlink" title="二、vw适配（推荐）"></a>二、vw适配（推荐）</h2><h3 id="原理与实现-1"><a href="#原理与实现-1" class="headerlink" title="原理与实现"></a>原理与实现</h3><p>vw/vh是将屏幕直接分为100等份，1vw是1%的屏幕宽度，1vh是1%的屏幕高度</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>比较方便，只需要css就可以实现适配</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>  vw、vh都是固定的，无法改变，和rem适配一样，对于大屏幕而言展示的内容较少</li></ul><!----><ul><li>  兼容性问题(ie11不支持，少数低版本手机不支持)，但目前兼容性越来越好</li></ul><h3 id="方案升级：vw-rem适配方案"><a href="#方案升级：vw-rem适配方案" class="headerlink" title="方案升级：vw+rem适配方案"></a>方案升级：vw+rem适配方案</h3><p>前文谈到，vw的缺点是无法改变，rem的缺点是需要使用js来设置，而且它们都有各自的优点，那么可以将这两者巧妙的结合来解决这个问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-comment">/*针对于750px的设计稿*/</span><br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">100</span>*<span class="hljs-number">100vw</span>/<span class="hljs-number">750</span>)<br>&#125;<br><br><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-comment">/*100px*/</span><br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">1rem</span>;<br>&#125;<br><br><span class="hljs-comment">/*媒体查询：适配大屏幕*/</span><br><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-width</span>: <span class="hljs-number">450px</span>) &#123;<br>  <span class="hljs-selector-tag">html</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calc</span>(<span class="hljs-number">50</span> * <span class="hljs-number">100vw</span> / <span class="hljs-number">750</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式还可以比较好的解决移动端1px的问题，详细可以参考<a href="https://jelly.jd.com/article/5f5a4b31da524a0147e97da0">最后一次探究1px</a>。</p><h3 id="插件使用（postcss-px-to-viewport）"><a href="#插件使用（postcss-px-to-viewport）" class="headerlink" title="插件使用（postcss-px-to-viewport）"></a>插件使用（postcss-px-to-viewport）</h3><p>详见<a href="https://www.npmjs.com/package/postcss-px-to-viewport">postcss-px-to-viewport传送门</a></p><h2 id="三、流式布局"><a href="#三、流式布局" class="headerlink" title="三、流式布局"></a>三、流式布局</h2><p>流式布局也就是百分比布局。比较简单粗暴，由于参考对象是父元素，尤其是嵌套层级比较深的时候，计算百分比的时候有时会有些许误差。</p><blockquote><ul><li>width/height：参考父元素</li><li>margin/padding：参考父元素的width</li><li>border-radius/background-size/tarnsform: 参考自身宽高</li></ul></blockquote><h2 id="四、响应式布局"><a href="#四、响应式布局" class="headerlink" title="四、响应式布局"></a>四、响应式布局</h2><p>通过媒体查询@media来适配不同屏幕大小，具体可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Media_Queries/Using_media_queries">MDN文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">// 用户设备的最小宽度为 680px<br><span class="hljs-meta">@media (<span class="hljs-params"><span class="hljs-built_in">min</span>-width: 680px</span>), screen &#123; ... &#125;</span><br><br>// <span class="hljs-built_in">min</span>-和<span class="hljs-built_in">max</span>-可以测试一个在两个值之间的宽度<br><span class="hljs-meta">@media (<span class="hljs-params"><span class="hljs-built_in">min</span>-width: 30em</span>) and (<span class="hljs-params"><span class="hljs-built_in">max</span>-width: 50em</span>) &#123; ... &#125;</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前比较推荐的移动适配方案是rem&amp;vw，rem&amp;媒体查询等，了解其中的适配原理对于前端而言是非常重要的，相关问题也经常出现在面试题中。虽然有很多插件可供使用，但是熟知其中奥秘也能给我们的工作带来很大的帮助。借以此文总结，如有错误欢迎指正，共勉。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>移动端适配</tag>
      
      <tag>工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue响应式原理探究之“发布-订阅”模式</title>
    <link href="/2022/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85/"/>
    <url>/2022/07/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在面试题中经常会出现与“发布订阅”模式相关的题目，比如考察我们对Vue响应式的理解，也会有题目直接考验我们对“发布订阅”模式或者观察者模式的理解，甚至还会有一些手写算法题。笔者就在今年三月参加某安全公司的面试时被要求手写代码实现“发布订阅”模式，当时由于没有准备没有回答上来，悔不该当初。由此可见“发布订阅”模式是一个非常重要的设计模式，接下来我们一起学习下吧。</p><h2 id="观察者模式-vs-“发布订阅”模式"><a href="#观察者模式-vs-“发布订阅”模式" class="headerlink" title="观察者模式 vs “发布订阅”模式"></a>观察者模式 vs “发布订阅”模式</h2><p>首先需要澄清的事，这两者虽然相似，却有不同。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>只涉及两个关键角色，发布者与订阅者。观察者模式定义了一种<strong>一对多</strong>的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/782e53d7273e4d07a659cfb2419451dc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h4 id="发布者的行为："><a href="#发布者的行为：" class="headerlink" title="发布者的行为："></a>发布者的行为：</h4><ol><li>增加订阅者</li><li>移除订阅者</li><li>通知所有订阅者</li></ol><p>代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-comment">// 定义发布者类</span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Publisher</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// 创建订阅者</span><br>    <span class="hljs-built_in">this</span>.observers = []<br>  &#125;<br>  <span class="hljs-comment">// 增加订阅者</span><br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">observer</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.observers.push(observer)<br>  &#125;<br>  <span class="hljs-comment">// 移除订阅者</span><br>  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">observer</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.observers.map(<span class="hljs-function">(<span class="hljs-params">item, i</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (item === observer) &#123;<br>        <span class="hljs-built_in">this</span>.observers.splice(i, <span class="hljs-number">1</span>)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 通知所有订阅者</span><br>  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.observers.map(<span class="hljs-function">(<span class="hljs-params">observer</span>) =&gt;</span> &#123;<br>      observer.update(<span class="hljs-built_in">this</span>)<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="订阅者行为："><a href="#订阅者行为：" class="headerlink" title="订阅者行为："></a>订阅者行为：</h4><ol><li>被通知</li><li>去执行</li></ol><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// 定义订阅者类  </span><br> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;创建订阅者&#x27;</span>)<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">update</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;订阅者更新&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="“发布订阅”模式"><a href="#“发布订阅”模式" class="headerlink" title="“发布订阅”模式"></a>“发布订阅”模式</h3><p>与观察者模式类似，但是在这种模式下发布者完全不用感知订阅者，不用关心它怎么实现回调方法，<strong>事件的注册和触发都发生在独立于双方的第三方平台（事件总线）上</strong>。发布-订阅模式下，实现了完全地解耦。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f03e57e6a59441fb90617ca4830a2b6~tplv-k3u1fbpfcp-watermark.image" alt="UML 图 (3).jpg"></p><h2 id="vue2-x响应式原理探究"><a href="#vue2-x响应式原理探究" class="headerlink" title="vue2.x响应式原理探究"></a>vue2.x响应式原理探究</h2><h3 id="响应式实现过程官方解释"><a href="#响应式实现过程官方解释" class="headerlink" title="响应式实现过程官方解释"></a>响应式实现过程官方解释</h3><ol><li> 在Vue data中存入对象数据</li><li> Vue遍历此对象每个property，通过Object.defineProperty()方法进行数据劫持，给每一个property加上getter/setter</li><li> 每个组件实例都对应一个Watcher实例，会收集所有接触过的property依赖，如果数据有变化，将会收到通知，watcher会使其关联的组件实例改变</li></ol><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/610422f632b54b3e8adf61f7db63cf20~tplv-k3u1fbpfcp-watermark.image" alt="UML 图 (2).jpg"></p><blockquote><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">深入理解响应式原理 官网文档v2</a></p></blockquote><h3 id="发布订阅模式在vue响应式原理中的具体运用"><a href="#发布订阅模式在vue响应式原理中的具体运用" class="headerlink" title="发布订阅模式在vue响应式原理中的具体运用"></a>发布订阅模式在vue响应式原理中的具体运用</h3><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vue</span> </span>&#123;  <br>  <span class="hljs-keyword">constructor</span>(options) &#123;  <br>    <span class="hljs-keyword">this</span>.$options = options;  <br>    <span class="hljs-keyword">this</span>.$<span class="hljs-keyword">data</span> = options.<span class="hljs-keyword">data</span>;  <br>        <br>    <span class="hljs-comment">// 对data选项做响应式处理  </span><br>    observe(<span class="hljs-keyword">this</span>.$<span class="hljs-keyword">data</span>);  <br>        <br>    <span class="hljs-comment">// 代理data到vm上  </span><br>    proxy(<span class="hljs-keyword">this</span>);  <br>        <br>    <span class="hljs-comment">// 执行编译  </span><br>    new Compile(options.el, <span class="hljs-keyword">this</span>);  <br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="发布者-伪订阅者：Observe"><a href="#发布者-伪订阅者：Observe" class="headerlink" title="发布者/伪订阅者：Observe"></a>发布者/伪订阅者：Observe</h4><p>observe在前文中代表了订阅者，但这里他更多的是一个发布者，执行了发布者的权利，增加了订阅者，并且在改变时通知了订阅者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observe</span>(<span class="hljs-params">obj</span>) </span>&#123;  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj !== <span class="hljs-string">&quot;object&quot;</span> || obj == <span class="hljs-literal">null</span>) &#123;  <br>    <span class="hljs-keyword">return</span>;  <br>  &#125;  <br>  <span class="hljs-keyword">new</span> Observer(obj);  <br>&#125;  <br>  <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;  <br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">value</span>)</span> &#123;  <br>    <span class="hljs-built_in">this</span>.value = value;<br>    <span class="hljs-built_in">Object</span>.keys(value).forEach(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;  <br>      defineReactive(value, key, value[key]);  <br>    &#125;); <br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p><code>defineReactive</code>是一个非常重要的方法，为每⼀个<code>key</code>创建⼀个<code>Dep</code>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">obj, key, val</span>) </span>&#123;  <br>  <span class="hljs-comment">// 递归遍历 确保深层次key也能够响应</span><br>  <span class="hljs-built_in">this</span>.observe(val);  <br>  <span class="hljs-comment">// 对每个key都建立一个Dep管家</span><br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep();  <br>  <span class="hljs-comment">// 使用defineProperty对每个key建立getter/setter</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;  <br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;  <br>      Dep.target &amp;&amp; dep.addDep(Dep.target);<span class="hljs-comment">// Dep.target也就是Watcher实例  </span><br>      <span class="hljs-keyword">return</span> val;  <br>    &#125;,  <br>    <span class="hljs-comment">// 监听变化</span><br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newVal</span>)</span> &#123;  <br>      <span class="hljs-keyword">if</span> (newVal === val) <span class="hljs-keyword">return</span>;  <br>      <span class="hljs-comment">// 通知dep执行更新方法 </span><br>      dep.notify(); <br>    &#125;,  <br>  &#125;);  <br>&#125; <br></code></pre></td></tr></table></figure><h4 id="事件中心：Dep管家，管理真实订阅者Wacther"><a href="#事件中心：Dep管家，管理真实订阅者Wacther" class="headerlink" title="事件中心：Dep管家，管理真实订阅者Wacther"></a>事件中心：Dep管家，管理真实订阅者Wacther</h4><p>Dep收集了组件实例中同一个key对应的所有订阅者Wacther</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 发布者</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;  <br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;  <br>    <span class="hljs-built_in">this</span>.deps = [];  <span class="hljs-comment">// 依赖管理  </span><br>  &#125;  <br>  <span class="hljs-function"><span class="hljs-title">addDep</span>(<span class="hljs-params">dep</span>)</span> &#123;  <br>    <span class="hljs-built_in">this</span>.deps.push(dep);  <br>  &#125;  <br>  <span class="hljs-function"><span class="hljs-title">notify</span>(<span class="hljs-params"></span>)</span> &#123;   <br>    <span class="hljs-comment">// 实际上是调用的watcher中的更新事件</span><br>    <span class="hljs-built_in">this</span>.deps.forEach(<span class="hljs-function">(<span class="hljs-params">dep</span>) =&gt;</span> dep.update());  <br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h4 id="实际的订阅者：Watcher"><a href="#实际的订阅者：Watcher" class="headerlink" title="实际的订阅者：Watcher"></a>实际的订阅者：Watcher</h4><p>通过触发get,将watcher添加到key对应的Dep中</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 订阅者 负责更新视图  </span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;  <br>  <span class="hljs-keyword">constructor</span>(vm, key, updater) &#123;  <br>    <span class="hljs-keyword">this</span>.vm = vm  <br>    <span class="hljs-keyword">this</span>.key = key  <br>    <span class="hljs-keyword">this</span>.updaterFn = updater  <br>    <span class="hljs-comment">// 创建实例时，把当前实例指定到Dep.target静态属性上  </span><br>    Dep.target = <span class="hljs-keyword">this</span>  <br>    <span class="hljs-comment">// 读一下key，触发get 便将watcher添加到key对应的Dep中  </span><br>    vm[key]  <br>    <span class="hljs-comment">// 置空  </span><br>    Dep.target = <span class="hljs-literal">null</span>  <br>  &#125;  <br>  <br>  <span class="hljs-comment">// 未来执行dom更新函数，由dep调用的  </span><br>  update() &#123;  <br>    <span class="hljs-keyword">this</span>.updaterFn.call(<span class="hljs-keyword">this</span>.vm, <span class="hljs-keyword">this</span>.vm[<span class="hljs-keyword">this</span>.key])  <br>  &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><h3 id="VUE2-X响应式的局限性"><a href="#VUE2-X响应式的局限性" class="headerlink" title="VUE2.X响应式的局限性"></a>VUE2.X响应式的局限性</h3><p>由于js的限制，Vue 不能检测数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p>Vue 无法检测 property 的添加或移除，因为Vue 会在<strong>初始化实例</strong>时对 property 执行 getter/setter 转化，所以只有在初始化实例时就存在于data的property才是响应式的。</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法或者其别名<code>vm.$set</code>向嵌套对象添加响应式 property。例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Vue.<span class="hljs-keyword">set</span>(vm.someObject, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.someObject,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>为已有对象赋值多个新 property，需用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`</span><br>this<span class="hljs-selector-class">.someObject</span> = Object<span class="hljs-selector-class">.assign</span>(&#123;&#125;, this<span class="hljs-selector-class">.someObject</span>, &#123; <span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span> &#125;)<br></code></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>Vue 不能检测以下数组的变动：</p><ol><li><p> 当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></p></li><li><p> 当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p></li></ol><p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将在响应式系统内触发状态更新：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// Vue.set</span><br>Vue.<span class="hljs-keyword">set</span>(vm.items, indexOfItem, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br></code></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// Array.prototype.splice</span><br>vm.items.splice(indexOfItem, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br></code></pre></td></tr></table></figure><p>你也可以使用 <code>vm.$set</code> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">vm.<span class="hljs-constructor">$set(<span class="hljs-params">vm</span>.<span class="hljs-params">items</span>, <span class="hljs-params">indexOfItem</span>, <span class="hljs-params">newValue</span>)</span><br></code></pre></td></tr></table></figure><p>为了解决第二类问题，你可以使用 <code>splice</code>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">vm.items.splice(<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>)<br></code></pre></td></tr></table></figure><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本篇文章讨论了发布订阅模式以及观察者模式，同时也讨论了发布订阅模式在vue2.x响应式中的应用，如有不对，欢迎指正，下一篇文章我将继续探究vue3.x的响应式原理，如果觉得写的还行就帮我点个赞吧，这样我会更有动力进行接下来的知识输出！谢谢各位朋友的观看！</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>策略模式</tag>
      
      <tag>发布订阅模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈前端常用设计模式</title>
    <link href="/2022/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%B5%85%E8%B0%88%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2022年，前端技术依旧日新月异，各种新兴技术或业务解决方案层出不穷。但我始终认为，在变与不变之间，唯有经典永恒，设计模式就是经典之一。在笔者从业期间，见过很多不同人写的代码，层次有高有低，将设计模式运用地行云流水的大佬，写出的代码总是令人觉着舒适优雅，有时恨不得顿足品读一番，相传小米创始人雷军写的代码就如同诗一般优雅；相反，不懂设计模式的开发者写出的代码总是一言难尽，甚至没有看下去的欲望，恨不得当场重构。。。</p><p>1995 年，GoF四人组开创性地提出 23 种设计模式，设计模式是前辈们对代码开发经验的总结，是解决特定问题的一系列套路，是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。站在巨人的肩膀上，能少走很多弯路，看到更多别样的风景。</p><p>本系列文章，笔者将会介绍在前端开发过程中，十分实用的一些设计模式，欢迎各位大佬补充讨论，本篇文章将介绍笔者最青睐的策略模式。</p><h2 id="策略模式（if-else的救世主"><a href="#策略模式（if-else的救世主" class="headerlink" title="策略模式（if-else的救世主)"></a>策略模式（if-else的救世主)</h2><p>策略模式（Strategy Pattern）指的是定义一系列的算法，把它们一个个封装起来，目的就是将算法的使用与算法的实现分离开来。</p><p>这里所指的算法，类似于一个策略，<strong>策略模式的核心思想</strong>就是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p><p>本质上来看就是我们老生常谈的解耦。如果一个复杂的系统，如果所有策略都耦合在业务逻辑里，日复一日随着需求的改变和增加，代码越来越庞杂，可维护性越来越低，但如果将策略与业务解耦，我们就可以独立维护这些策略，为业务带来更灵活的变化。</p><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><p>举一个比较常见的例子，我们会遇到枚举值转换的问题，比如下面我们需要维护一个优惠券的类型，简单粗暴的想我们会直接用if-else直接梭哈。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> getCouponText = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;免费券&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;立减券&#x27;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;折扣券&#x27;</span><br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>但如果我们想要我们的代码可维护性更高的话，首先我们需要对这个枚举值做一个统一的维护管理（枚举值统一管理是笔者推荐的，可以使得代码更语义化，不属于策略模式的内容），提升代码的可读性，然后使用<strong>对象映射</strong>来将逻辑分离出来，解放了if-else，特别是逻辑非常重的时候，用这个方法逻辑更为清晰明了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> COUPON_TYPE = &#123;<br>    <span class="hljs-attr">FREE</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 免费</span><br>    <span class="hljs-attr">DISCOUNT</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 折扣</span><br>    <span class="hljs-attr">REDUCE</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 立减</span><br>&#125;;<br><span class="hljs-keyword">const</span> COUPON_TYPES = &#123;<br>    [COUPON_TYPE.FREE]: <span class="hljs-string">&#x27;免费券&#x27;</span>,<br>    [COUPON_TYPE.DISCOUNT]: <span class="hljs-string">&#x27;折扣券&#x27;</span>,<br>    [COUPON_TYPE.REDUCE]: <span class="hljs-string">&#x27;立减券&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> getCouponText = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> COUPON_TYPES[type]||<span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在具体的业务中，我们也会使用到这些枚举值，来对不同的枚举进行不同的操作判断，这时候我们往往又会写一些if-else判断逻辑，随着业务类型的增加，我们只能不停地往里面堆代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> handleType = <span class="hljs-function">(<span class="hljs-params">type</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (type === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">do</span> sth<br>        <span class="hljs-keyword">do</span> sth<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">do</span> sth<br>        <span class="hljs-keyword">do</span> sth<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type === <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">do</span> sth<br>        <span class="hljs-keyword">do</span> sth<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>同样地，我们使用策略模式也可以将这段代码变得更为优雅，使用一个对象专门用来维护这些对应的方法事件，每个类型对应一个方法，遵循了单一原则。</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs moonscript">const couponFunctions = &#123;<br>    [COUPON_TYPE.FREE]: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">do</span> sth&#125;,<br>    [COUPON_TYPE.DISCOUNT]: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">do</span> sth &#125;,<br>    [COUPON_TYPE.REDUCE]: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">do</span> sth &#125;<br>&#125;<br>const handleType = <span class="hljs-function"><span class="hljs-params">(<span class="hljs-built_in">type</span>)</span> =&gt;</span> &#123;<br>    couponFunctions[<span class="hljs-built_in">type</span>] &amp;&amp; couponFunctions[<span class="hljs-built_in">type</span>]()<br>&#125;<br></code></pre></td></tr></table></figure><p>笔者认为策略模式是非常好用的，特别是对于一些比较”重”的逻辑，各种if-else乱象，使用策略模式能够让代码更通俗易懂，每次改动代码的时候，只需要修改对应的内容就行，不至于在庞杂的逻辑下慌乱了阵脚。</p><h2 id="感谢观看"><a href="#感谢观看" class="headerlink" title="感谢观看"></a>感谢观看</h2><p>本篇文章只介绍了策略模式，但其实另外很多设计模式也比较实用，比如观察者模式、原型模式、代理模式、装饰器模式、单例模式等，都能给我们书写代码带来新的思路和方案，有兴趣的话大家可以继续了解下，我抽时间也会把相关内容补上来和大家一起学习探讨。</p><p>最后，感谢观看。我是阿李贝斯，如果你觉得本篇文章对你有帮助的话，欢迎收藏点赞，我会更有动力进行知识输出，希望和掘金的各位大佬一起共同进步，用知识对抗未知！</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用github pages + github Actions + VuePress构建站点</title>
    <link href="/2022/04/08/github/github-pages/"/>
    <url>/2022/04/08/github/github-pages/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用github-pages-github-Actions-VuePress构建站点"><a href="#如何使用github-pages-github-Actions-VuePress构建站点" class="headerlink" title="如何使用github pages + github Actions + VuePress构建站点"></a>如何使用github pages + github Actions + VuePress构建站点</h1><p>最近一直想着将自己零零碎碎的笔记文档归纳一下，刚好之前看到好几个用Vuepress构建的文档都很清晰明了，又想尝试下github自带的CI/CD功能，所以就想使用github pages + github Actions + VuePress构建属于自己学习的站点。</p><p>这样既可以满足作为一个程序员习惯使用自己的编辑器记录的心理，可以清晰的看到自己的历史提交记录，又可以通过自己建立的学习站点访问构建好学习文档沉浸式学习，实在是非常好的体验。</p><p>以下我会建立一个有关算法的学习站点作为示范。</p><h2 id="使用VuePress构建项目"><a href="#使用VuePress构建项目" class="headerlink" title="使用VuePress构建项目"></a>使用VuePress构建项目</h2><p>VuePress 诞生初衷是为了支持 Vue 及其子项目的文档需求，每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。</p><blockquote><p><a href="https://vuepress.vuejs.org/zh/guide">vuepress官方文档链接</a></p></blockquote><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir algorithm-learn &amp;&amp; cd algorithm-learn<br>npm init<br>npm install -D vuepress<br></code></pre></td></tr></table></figure><h3 id="创建自己的第一个文档"><a href="#创建自己的第一个文档" class="headerlink" title="创建自己的第一个文档"></a>创建自己的第一个文档</h3><p><img src="/img/github/1.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir docs &amp;&amp; echo &#x27;# Hello algorithm&#x27; &gt; docs/README.md<br></code></pre></td></tr></table></figure><blockquote><p>温馨提示： echo写入的方式可能会导致文档乱码，如发生这种情况请手动创建</p></blockquote><h3 id="在docs夹子下创建vuepress的配置文件"><a href="#在docs夹子下创建vuepress的配置文件" class="headerlink" title="在docs夹子下创建vuepress的配置文件"></a>在docs夹子下创建vuepress的配置文件</h3><p><img src="/img/github/2.png"></p><blockquote><p>可以自己更换相关字段</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;算法学习&#x27;</span>,<br>  <span class="hljs-attr">description</span>: <span class="hljs-string">&#x27;Just playing around&#x27;</span>,<br>  <span class="hljs-attr">base</span>: <span class="hljs-string">&#x27;/algorithm-learn/&#x27;</span>,<br>  <span class="hljs-attr">configureWebpack</span>: &#123;<br>    <span class="hljs-attr">resolve</span>: &#123;<br>      <span class="hljs-attr">alias</span>: &#123;<br>        <span class="hljs-comment">// &quot;@alias&quot;: &quot;path/to/some/dir&quot;,</span><br>      &#125;,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-comment">// theme: &#x27;reco&#x27;,</span><br>  <span class="hljs-attr">locales</span>: &#123;<br>    <span class="hljs-string">&#x27;/&#x27;</span>: &#123;<br>      <span class="hljs-attr">lang</span>: <span class="hljs-string">&#x27;zh-CN&#x27;</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-attr">themeConfig</span>: &#123;<br>    <span class="hljs-attr">subSidebar</span>: <span class="hljs-string">&#x27;auto&#x27;</span>,<br>    <span class="hljs-attr">nav</span>: [<br>      &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;首页&#x27;</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">&#x27;/&#x27;</span> &#125;,<br>      &#123;<br>        <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;了解更多&#x27;</span>,<br>        <span class="hljs-attr">items</span>: [<br>          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Github&#x27;</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">&#x27;https://github.com/strugglinglee&#x27;</span> &#125;,<br>          &#123;<br>            <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;博客&#x27;</span>,<br>            <span class="hljs-attr">link</span>: <span class="hljs-string">&#x27;https://blog.strugglinglee.cn/&#x27;</span>,<br>          &#125;,<br>        ],<br>      &#125;,<br>    ],<br>    <span class="hljs-attr">sidebar</span>: [<br>    <span class="hljs-comment">//   &#123;</span><br>    <span class="hljs-comment">//     title: &#x27;JS基础&#x27;,</span><br>    <span class="hljs-comment">//     // path: &#x27;/JavaScript&#x27;,</span><br>    <span class="hljs-comment">//     collapsable: true,</span><br>    <span class="hljs-comment">//     children: [],</span><br>    <span class="hljs-comment">//   &#125;</span><br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="在package-json文件中增加这些命令"><a href="#在package-json文件中增加这些命令" class="headerlink" title="在package.json文件中增加这些命令"></a>在package.json文件中增加这些命令</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;vuepress dev docs&quot;</span>,<br>  <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;vuepress build docs&quot;</span><br>&#125;,<br></code></pre></td></tr></table></figure><p>执行<code>npm run dev</code>就可以在本地看到一个初步的文档了</p><h2 id="github-Actions-github-pages操作流程"><a href="#github-Actions-github-pages操作流程" class="headerlink" title="github Actions + github pages操作流程"></a>github Actions + github pages操作流程</h2><h3 id="在github创建自己的仓库"><a href="#在github创建自己的仓库" class="headerlink" title="在github创建自己的仓库"></a>在github创建自己的仓库</h3><p><img src="/img/github/3.png"><br>并按照常规顺序把本地代码推到远程（略）</p><h3 id="创建actions"><a href="#创建actions" class="headerlink" title="创建actions"></a>创建actions</h3><p>搜索node,并在github上面的界面提交自动创建的代码，然后将代码拉到本地<br><img src="/img/github/4.png"><br><img src="/img/github/5-1.png"><br><img src="/img/github/5.png"></p><p>参考如下代码替换node.js.yml文件</p><blockquote><p>这里我们使用到了<a href="https://github.com/JamesIves/github-pages-deploy-action">JamesIves</a>，注意版本的更新，可以参考github仓库中的说明文件。<br><code>JamesIves</code>也是阮一峰老师曾经在博文中推荐过的，目前star已近3k，还是可以放心使用的。</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">CI</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">main</span> ]<br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">main</span> ]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">node-version:</span> [<span class="hljs-number">14.</span><span class="hljs-string">x</span>]<br>        <span class="hljs-comment"># See supported Node.js release schedule at https://nodejs.org/en/about/releases/</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">🛎️</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">and</span> <span class="hljs-string">Build</span> <span class="hljs-string">🔧</span> <span class="hljs-comment"># This example project is built using npm and outputs the result to the &#x27;build&#x27; folder. Replace with the commands required to build your project, or remove this step entirely if your site is pre-built.</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install yarn -g</span><br><span class="hljs-string">          yarn install</span><br><span class="hljs-string">          yarn run build</span><br><span class="hljs-string"></span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">🚀</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">JamesIves/github-pages-deploy-action@v4.3.0</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span> <span class="hljs-comment"># The branch the action should deploy to.</span><br>          <span class="hljs-attr">ACCESS_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.access_token_key</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">FOLDER:</span> <span class="hljs-string">docs/.vuepress/dist</span><br>          <span class="hljs-attr">CLEAN:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><h3 id="将本地代码推送到远程"><a href="#将本地代码推送到远程" class="headerlink" title="将本地代码推送到远程"></a>将本地代码推送到远程</h3><p>远程将会创建一个gh-pages分支，这个分支上的代码就是我们构建出的最后站点所需要的资源</p><p><img src="/img/github/6.png"></p><h3 id="设置github-pages"><a href="#设置github-pages" class="headerlink" title="设置github pages"></a>设置github pages</h3><p><img src="/img/github/9.png"></p><h2 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h2><p>通过链接访问<a href="https://strugglinglee.github.io/algorithm-learn/">https://strugglinglee.github.io/algorithm-learn/</a></p><p><img src="/img/github/10.png"></p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/strugglinglee/algorithm-learn">https://github.com/strugglinglee/algorithm-learn</a></p>]]></content>
    
    
    <categories>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github pages</tag>
      
      <tag>github Actions</tag>
      
      <tag>VuePress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法基础之数据结构</title>
    <link href="/2022/01/25/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/01/25/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>初始化一个数组，不知道它内部元素的情况下，推荐使用构造函数创建数组的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//不传任何参数，得到一个空数组</span><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>()<br><span class="hljs-comment">//指定长度数组</span><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>)<br><span class="hljs-comment">//指定长度，指定元素的数组</span><br><span class="hljs-keyword">const</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>).fill(<span class="hljs-number">7</span>)<br></code></pre></td></tr></table></figure><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>从性能上看，for循环遍历起来是最快的</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二维数组，也就是数组套数组</p><p>在数学中，形如这样长方阵列排列的复数或实数集合，被称为“矩阵”。因此二维数组的别名就叫“矩阵”。</p><h3 id="创建二维数组"><a href="#创建二维数组" class="headerlink" title="创建二维数组"></a>创建二维数组</h3><h4 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h4><p>fill入参是引用类型，指向同一个堆内存空间，改变其中一个数组，其他的都会跟着改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr =(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">7</span>)).fill([])<br></code></pre></td></tr></table></figure><h4 id="正确写法"><a href="#正确写法" class="headerlink" title="正确写法"></a>正确写法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> len = arr.length<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;len;i++) &#123;<br>    <span class="hljs-comment">// 将数组的每一个坑位初始化为数组</span><br>    arr[i] = []<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维数组的访问"><a href="#二维数组的访问" class="headerlink" title="二维数组的访问"></a>二维数组的访问</h3><p>两层for循环，依次类推，N 维数组需要 N 层循环来完成遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 缓存外部数组的长度</span><br><span class="hljs-keyword">const</span> outerLen = arr.length<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i=<span class="hljs-number">0</span>;i&lt;outerLen;i++) &#123;<br>    <span class="hljs-comment">// 缓存内部数组的长度</span><br>    <span class="hljs-keyword">const</span> innerLen = arr[i].length<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> j=<span class="hljs-number">0</span>;j&lt;innerLen;j++) &#123;<br>        <span class="hljs-comment">// 输出数组的值，输出数组的索引</span><br>        <span class="hljs-built_in">console</span>.log(arr[i][j],i,j)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p>栈和队列的实现一般都依赖于数组</p><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>后进先出(LIFO，last in first out)的数据结构</p><blockquote><p>最先出来的称为<code>栈顶元素</code>，主要关心栈顶元素</p></blockquote><p>只用<code>pop</code>和<code>push</code>完成增删的数组</p><ul><li>只允许从尾部添加元素</li><li>只允许从尾部取出元素</li></ul><blockquote><p>形象记忆：拿东西，后放进去的在表层，可以最先拿出来</p></blockquote><h3 id="队列（Quene）"><a href="#队列（Quene）" class="headerlink" title="队列（Quene）"></a>队列（Quene）</h3><p>先进先出（FIFO,First in first out）的数据结构</p><blockquote><p>最先出来的称为<code>队头元素</code>，主要关心队头元素</p></blockquote><p>只用<code>push</code>和<code>shift</code>完成增删的数组</p><ul><li>只允许从尾部添加元素</li><li>只允许从头部移除元素</li></ul><blockquote><p>形象记忆：排队吃饭，先进先出</p></blockquote><h3 id="队列-vs-栈"><a href="#队列-vs-栈" class="headerlink" title="队列 vs 栈"></a>队列 vs 栈</h3><table><thead><tr><th>特性</th><th>队列</th><th>栈</th></tr></thead><tbody><tr><td>添加元素方法</td><td>push()</td><td>push()</td></tr><tr><td>删除元素方法</td><td><strong>shift()</strong></td><td><strong>pop()</strong></td></tr><tr><td>最先出来的</td><td><strong>队头</strong>元素</td><td><strong>栈顶</strong>元素</td></tr><tr><td>出入方式</td><td>先进先出</td><td>后进先出</td></tr></tbody></table><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>和数组相似，又是有序的列表，都是<code>线性结构</code>（有且只有一个前驱，有且只有一个后继）</p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>数据单位的名称叫做“结点”，结点和结点的分布，在内存中可以是离散的</p><p>在链表中，每一个结点的结构都包括了两部分内容：</p><ol><li>数据域(存储的是当前结点所存储的数据值)</li><li>指针域(代表下一个结点-后继结点的引用)</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>    <span class="hljs-comment">// 数据域</span><br>    <span class="hljs-attr">val</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-comment">// 指针域，指向下一个结点</span><br>    <span class="hljs-attr">next</span>: &#123;<br>        <span class="hljs-attr">val</span>:<span class="hljs-number">2</span>,<br>        <span class="hljs-attr">next</span>: ...<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListNode</span>(<span class="hljs-params">val</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.val = val;<br>    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。</p><h3 id="链表的删除"><a href="#链表的删除" class="headerlink" title="链表的删除"></a>链表的删除</h3><p><strong>重点:定位目标结点的前驱结点</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = node1.next<br>node1.next = target.next<br></code></pre></td></tr></table></figure><h3 id="链表节点的创建"><a href="#链表节点的创建" class="headerlink" title="链表节点的创建"></a>链表节点的创建</h3><p>在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> node = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>)<br>node.next = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="链表节点的插入"><a href="#链表节点的插入" class="headerlink" title="链表节点的插入"></a>链表节点的插入</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果目标结点本来不存在，那么记得手动创建</span><br><span class="hljs-keyword">const</span> node3 = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>)<br><span class="hljs-comment">// 把node3的 next 指针指向 node2（即 node1.next）</span><br>node3.next = node1.next<br><span class="hljs-comment">// 把node1的 next 指针指向 node3</span><br>node1.next = node3<br></code></pre></td></tr></table></figure><h2 id="链表和数组的辨析"><a href="#链表和数组的辨析" class="headerlink" title="链表和数组的辨析"></a>链表和数组的辨析</h2><table><thead><tr><th></th><th>链表</th><th>数组</th></tr></thead><tbody><tr><td>增删时间复杂度</td><td>常数级别的复杂度，<strong>O(1)</strong></td><td>随着数组长度 n 的增大而增大，呈一个线性关系。<strong>O(n)</strong></td></tr><tr><td>查找时间复杂度</td><td>当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它，呈线性规律，<strong>O(n)</strong></td><td>直接访问索引、可以做到一步到位，这个操作的复杂度会被降级为常数级别<strong>O(1)</strong></td></tr><tr><td>效率</td><td><strong>插入/删除效率较高，访问效率较低</strong></td><td><strong>访问效率较高，而插入效率较低</strong></td></tr></tbody></table><p><strong>JS数组未必是真正的数组</strong><br>数组定义了不同类型的元素，对应的是一段非连续的内存，JS数组在此时不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;haha&#x27;</span>,<span class="hljs-number">1</span>,&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;]<br></code></pre></td></tr></table></figure><blockquote><p>真正的数组：“存储在连续的内存空间里”这样的必要条件</p></blockquote><p><strong>链表明显的优点：</strong><br>添加和删除元素都不需要挪动多余的元素。</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li><strong>度</strong>：一个结点开叉出去多少个子树，被记为结点的“度”</li><li><strong>叶子结点</strong>：度为0的结点</li><li><strong>树的高度</strong>：<code>叶子结点</code>高度为1，每向上一层高度加一，逐层向上累加至目标结点，所得的的值就是目标结点的高度，树中结点的最大高度称为“树的高度”</li><li>根结点所在的为第一层，子结点所在的为第二层</li></ul><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul><li>可以没有根结点，作为一棵<code>空树</code>存在</li><li>如果它不是空树，那么必须由<code>根结点</code>、<code>左子树</code>和<code>右子树</code>组成，且左右子树都是<code>二叉树</code>。</li></ul><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>在 JS 中，二叉树使用对象来定义。它的结构分为三块：</p><ol><li>数据域</li><li>左侧子结点（左子树根结点）的引用</li><li>右侧子结点（右子树根结点）的引用</li></ol><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>左右侧子节点预置为空</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 二叉树结点的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TreeNode</span>(<span class="hljs-params">val</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.val = val;<br>    <span class="hljs-built_in">this</span>.left = <span class="hljs-built_in">this</span>.right = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-comment">// 二叉树创建</span><br><span class="hljs-keyword">const</span> node  = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h4><p><strong>按遍历顺序分为：</strong></p><ol><li>先序遍历</li><li>中序遍历</li><li>后序遍历</li><li>层次遍历</li></ol><p><strong>按实现方式分为：</strong></p><ol><li>递归遍历（先、中、后序遍历）</li><li>迭代遍历（层次遍历）</li></ol><p><strong>先序遍历</strong>：<strong>根结点</strong> -&gt; 左子树 -&gt; 右子树<br><strong>中序遍历</strong>：左子树 -&gt; <strong>根结点</strong> -&gt; 右子树<br><strong>后序遍历</strong>：左子树 -&gt; 右子树 -&gt; <strong>根结点</strong></p><blockquote><p><strong>方便记忆</strong>：对于<code>根结点</code>遍历的位置来定的</p></blockquote><h4 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 先序遍历</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">preOrder</span>(<span class="hljs-params">root</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!root)&#123;<br>    <span class="hljs-keyword">return</span><br>  &#125;<br>  <span class="hljs-comment">// 当前遍历节点</span><br>  <span class="hljs-built_in">console</span>.log(root.val)<br>  <span class="hljs-comment">// 左子树</span><br>  preOrder(root.left)<br>  <span class="hljs-comment">// 右子树</span><br>  preOrder(root.right)<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>算法基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态网站H5直接跳转小程序解决方案</title>
    <link href="/2021/11/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%20H5%20%E8%B7%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/11/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%20H5%20%E8%B7%B3%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>本文主要讲述使用云开发通过h5来唤起小程序的方案，之前在实际开发过程中遇到了一些问题，网络上关于这些的参考资料较少，故以此篇文章总结一下。</p><p>暂未了解过这方面的朋友，可以通过点击<a href="https://postpay-2g5hm2oxbbb721a4-1258211818.tcloudbaseapp.com/jump-mp.html">这个链接</a>来体验一下</p><blockquote><p>可以在微信内部浏览器的 H5 跳转小程序，也可以在微信外部浏览器或其他部分 App （如企业微信、QQ 等）跳转微信小程序。</p></blockquote><p>非个人主体并且已认证的(微信认证)小程序，使用云开发静态网站托管的网页，可以免鉴权跳转任意合法合规的小程序。这个静态网页可以直接copy这段html代码<a href="https://res.wx.qq.com/op_res/4gUvxyfsT9OaDBWFG_jP-xtGK84CoO_4rQXZpaJhyje-vy3amU1xLctcpyqfyn3D5rgCRBR3EpR5sLO_WSP8eQ" target="_blank" rel="noopener noreferrer">点击下载<span></span></a>，然后在此基础进行修改。</p><blockquote><p>具体可以参考<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/staticstorage/jump-miniprogram.html">微信官方文档</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>weapp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>小程序云开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拒绝愚蠢的活着</title>
    <link href="/2021/11/07/%E6%9D%82%E8%B0%88/%E6%8B%92%E7%BB%9D%E6%84%9A%E8%A0%A2%E7%9A%84%E6%B4%BB%E7%9D%80/"/>
    <url>/2021/11/07/%E6%9D%82%E8%B0%88/%E6%8B%92%E7%BB%9D%E6%84%9A%E8%A0%A2%E7%9A%84%E6%B4%BB%E7%9D%80/</url>
    
    <content type="html"><![CDATA[<p>从小时候开始，我们便会被问到，你的梦想是什么？</p><p>科学家？老师？画家？作家…… 我们的答案或许五花八门，我却认为实质一样。</p><p>我们从小就被培养了追求更好生活的习惯，心中有无限追求，无限渴望。</p><p>但这其实潜移默化的养成了我们的懒惰性格，对未来的憧憬太多，太美好，便会觉得反正短期不会实现，不如得过且过，止步于现实。包括我自己，总觉得未来某个时候，或许，侥幸，maybe，幸福美好就会自然光临。偶尔抱怨几句现实不公，或是破罐子破摔，或是将就着过，将自己的希望无限期延长，到了暮年，唏嘘几句，寥寥此生虚度。</p><p>最近愈发觉得执行力是非常宝贵的能力。</p><p>列举一个常见“偷懒”行为，工作中，其实我们会遇到很多新问题，这个“新问题”可能是之前遇到过的，却怎么都想不起来解决方法，只因我们无脑做了同一件事—-百度找到这个问题的答案。</p><p>对待所有的新问题，都应该有一种想究其根本的态度，而不是图一时之快草草的解决，我们应该将自己的人设定为思考者，或是探险家之类的，动用自己潜能无限的大脑去思考，或者查阅各种资料使自己完全的弄懂，甚至借助于此，完善自己的知识体系，而不是一个只追求快的冷漠机器。我们从来都不是机器，除非你自己觉得你是。</p><p>偷懒其实就是逃避，虽然你偷懒做了这件事，实则与没做无异。</p><p>对于工作，执行力意味着不断记录，不断总结，不断思考，不断挑战自我，而这些更是成功的基石。</p><p>对于生活，对于未来。美好的期望也很多，但其实最好的生活方式应该是有规划的。虽然计划赶不上变化，但充足的准备足以应对变化带来的变数。我最讨厌的字眼莫过于，得过且过，顺其自然这类。虽然这些字眼在我某些难熬的时期拉了我一把，但正值青春年华，这些字眼绝不能够成为我们的人生信条。不甘平庸，敢于追求，敢折腾，不怕失败才应该成为我们的主色彩。</p><p>其实大多数的人都在愚蠢的活着，眼前也只有周遭的一切，快乐也大多止步于低级趣味。感觉无形之中好像有一根线拉着我们，我们像是被拉扯着的木偶。这个世界的条条框框很多，人生也有很多的无奈与无常，但仍然有人过的很精彩，很重要的是他们战胜了自己的动物性，又或者说是奴隶性（习惯了被指导，习惯了走别人走过的路），能够自己主导自己的人生，做自己人生的导演。 《沙丘》里面有一段对白很精彩，大概意思就是，只要战胜了恐惧，你就能战胜一切。不必畏惧他人眼光，不必担心自己不行，只有走在自己想走的路上的时候，这条路才被赋予了意义和价值。</p><p>其实说了这么多，不过是不满足现状，进行了自我忏悔和剖析。真的有好多想做的事，好多的想自我提升的地方。不想再继续做思想上的巨人，行动上的矮子了。不想做一个只有梦想的人，我要梦想变现实，必须从现在开始，有温度有智慧地活着。2021已经快过去了，但已逝去的时光都只能算沉没成本，无需浪费时间感叹，希望今后自己的关键字能有这些：“勇敢”，“规划”，“执行力”。</p><p>以上，与君共勉。</p>]]></content>
    
    
    <categories>
      
      <category>人生感悟</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>探究css垂直居中</title>
    <link href="/2021/07/24/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%8E%A2%E7%A9%B6/"/>
    <url>/2021/07/24/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E6%8E%A2%E7%A9%B6/</url>
    
    <content type="html"><![CDATA[<p>很多人开始接触到文字垂直居中的时候一般都是靠以下两行代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">line-height</span>: <span class="hljs-number">24px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">24px</span>;<br></code></pre></td></tr></table></figure><p>其实这个概念是很容易误导初学者的，line-height只是使控制文字对齐的元素之一，下面介绍下相关的知识，并解释下为什么仅靠这两行代码并不能实现精确的垂直居中。</p><h3 id="内联元素默认基线对齐（vertical-align-baseline）"><a href="#内联元素默认基线对齐（vertical-align-baseline）" class="headerlink" title="内联元素默认基线对齐（vertical-align:baseline）"></a>内联元素默认基线对齐（vertical-align:baseline）</h3><h4 id="哪些元素是内联元素？"><a href="#哪些元素是内联元素？" class="headerlink" title="哪些元素是内联元素？"></a>哪些元素是内联元素？</h4><p>display为inline/inline-block/inline-table的都属于内联元素。<br><img src="/img/line-height/2.png"></p><p>从表现行为上来看，“内联元素”典型的特征就是和文字在一行显示，因此<code>文字/图片/按钮/输入框/下拉框</code>等表单控件也是内联元素。—引自 张鑫旭 《css世界》</p><p><strong>重点：文字属于内联元素，沿基线对齐。</strong><br>文章开头提出的问题有答案了，当你指定line-height之后，所有的内联元素还是沿着基线对齐，所以仅靠line-height是无法完成文字的垂直居中的。</p><h4 id="什么是基线（baseline）？"><a href="#什么是基线（baseline）？" class="headerlink" title="什么是基线（baseline）？"></a>什么是基线（baseline）？</h4><p><strong><code>小写字母x</code>的下边缘就是我们的基线</strong></p><blockquote><p>为什么会选小写字母x为基线，很容易想通，小写字母是轴对称图形，上下边都是平整的，而不是像s一样上下边是弯曲的。</p></blockquote><h5 id="扩展概念：x-height"><a href="#扩展概念：x-height" class="headerlink" title="扩展概念：x-height"></a>扩展概念：x-height</h5><p>定义：小写字母x的高度<br>扩展：尺寸单位ex是css中的一个相对单位，指的是小写字母x的高度（x-height）</p><h3 id="line-height（行高）"><a href="#line-height（行高）" class="headerlink" title="line-height（行高）"></a>line-height（行高）</h3><p>定义的就是两行基线的间距</p><h4 id="可能出现的值："><a href="#可能出现的值：" class="headerlink" title="可能出现的值："></a>可能出现的值：</h4><ul><li>数值：所有的子元素继承的都是这个值</li><li>百分比或者长度值：所有的子元素继承的是最终的计算值</li></ul><blockquote><p>提示：内联元素span不能设置宽高，但支持line-height行高设置</p></blockquote><h3 id="line-height的好基友vertical-align"><a href="#line-height的好基友vertical-align" class="headerlink" title="line-height的好基友vertical-align"></a>line-height的好基友<code>vertical-align</code></h3><h4 id="vertical-align的属性值"><a href="#vertical-align的属性值" class="headerlink" title="vertical-align的属性值"></a>vertical-align的属性值</h4><ul><li>线类：baseline(default)/top/middle/bottom</li><li>文本类：text-top/text-bottom</li><li>上标下标类：sub/super</li><li>数值百分比类：20px/2em/20%(后面两个比较少用)</li></ul><h4 id="line-height-vertical-align-middle也只是近似的垂直居中"><a href="#line-height-vertical-align-middle也只是近似的垂直居中" class="headerlink" title="line-height+vertical-align:middle也只是近似的垂直居中"></a>line-height+vertical-align:middle也只是近似的垂直居中</h4><p><img src="/img/line-height/3.png"><br>middle是指沿着基线往上1/2 x-height高度对齐，可以近似理解为字母x交叉点的位置</p><blockquote><p>并不是绝对的居中对齐，因为不同的字体在行内盒子中的位置不一样，比如微软雅黑就是一个下沉比较明显的字体，所有字符的位置都比其他字体要偏下一点，字母x的交叉点是在容器中分线的下面一点。</p></blockquote><h4 id="vertical-align为一个数值来解决精确垂直居中的问题"><a href="#vertical-align为一个数值来解决精确垂直居中的问题" class="headerlink" title="vertical-align为一个数值来解决精确垂直居中的问题"></a>vertical-align为一个数值来解决精确垂直居中的问题</h4><p>vertical-align:baseline其实就是vertical-align:0<br>需要精确解决垂直居中的问题是需要在这个基础上进行调试的，比如设置vertical-align为-5px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">vertical-align</span>:-<span class="hljs-number">5px</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/line-height/4.png"></p><h4 id="注意点：-vertical-align作用条件"><a href="#注意点：-vertical-align作用条件" class="headerlink" title="注意点： vertical-align作用条件"></a>注意点： vertical-align作用条件</h4><p>可能会有人觉得vertical-align看似好用，但是有时候不起作用，但其实你需要知道它的使用条件：<strong>只能应用于内联元素以及display值为table-cell的元素</strong></p><h3 id="探索：display-flex-align-items-center能实现精确的文字垂直居中吗？"><a href="#探索：display-flex-align-items-center能实现精确的文字垂直居中吗？" class="headerlink" title="探索：display:flex+align-items:center能实现精确的文字垂直居中吗？"></a>探索：display:flex+align-items:center能实现精确的文字垂直居中吗？</h3><p>我们不如先来尝试下</p><p><img src="/img/line-height/5.png"><br>可以见得，万能的flex布局实现了文字垂直居中，但文字受到多种因素的影响，精确的垂直居中其实是比较难实现的。</p><h3 id="补充知识：div的高度是由行高决定的"><a href="#补充知识：div的高度是由行高决定的" class="headerlink" title="补充知识：div的高度是由行高决定的"></a>补充知识：div的高度是由行高决定的</h3><blockquote><ol><li>知识补充：替换元素（如image/video/input等这种替换某个属性就可以改变的元素）</li><li>行距 = line-height - font-size</li><li>半行距 = 行距 / 2</li></ol></blockquote><p>对于块级元素，line-height对其本身是没有任何作用的，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高实现的</p><ul><li>对于非替换元素的纯内联元素，其可视高度完全由line-height决定</li><li>纯文本：line-height决定最终高度</li><li>子元素含有替换元素，line-height只能决定最小高度<blockquote><p>原因：一是替换元素的高度不受line-height影响，二是vertical-align属性在背后作祟</p></blockquote></li></ul><h3 id="有意思的概念：幽灵空白节点"><a href="#有意思的概念：幽灵空白节点" class="headerlink" title="有意思的概念：幽灵空白节点"></a>有意思的概念：幽灵空白节点</h3><p><code>内联元素</code>的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。<br><code>透明</code>，<code>不占据任何宽度和高度</code>，就好像幽灵一样，看不见，却又确实撑开了父元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">display</span>:inline-block</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/line-height/1.png"></p><blockquote><p>对幽灵空白节点的解释：可以认为在span元素的前面还有一个宽度为0的空白字符。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实对于前端来说，市面上常见的垂直居中方案是足以满足我们的需求的，有时候受到字体因素等的影响有略微差距其实也是可以接受的，只要你弄清楚它的原理或许你就不会这么困惑了。<br>很多人开始接触到文字垂直居中的时候一般都是靠以下两行代码</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">line-height</span>: <span class="hljs-number">24px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">24px</span>;<br></code></pre></td></tr></table></figure><p>其实这个概念是很容易误导初学者的，line-height只是使控制文字对齐的元素之一，下面介绍下相关的知识，并解释下为什么仅靠这两行代码并不能实现精确的垂直居中。</p><h3 id="内联元素默认基线对齐（vertical-align-baseline）-1"><a href="#内联元素默认基线对齐（vertical-align-baseline）-1" class="headerlink" title="内联元素默认基线对齐（vertical-align:baseline）"></a>内联元素默认基线对齐（vertical-align:baseline）</h3><h4 id="哪些元素是内联元素？-1"><a href="#哪些元素是内联元素？-1" class="headerlink" title="哪些元素是内联元素？"></a>哪些元素是内联元素？</h4><p>display为inline/inline-block/inline-table的都属于内联元素。<br><img src="/img/line-height/2.png"></p><p>从表现行为上来看，“内联元素”典型的特征就是和文字在一行显示，因此<code>文字/图片/按钮/输入框/下拉框</code>等表单控件也是内联元素。—引自 张鑫旭 《css世界》</p><p><strong>重点：文字属于内联元素，沿基线对齐。</strong><br>文章开头提出的问题有答案了，当你指定line-height之后，所有的内联元素还是沿着基线对齐，所以仅靠line-height是无法完成文字的垂直居中的。</p><h4 id="什么是基线（baseline）？-1"><a href="#什么是基线（baseline）？-1" class="headerlink" title="什么是基线（baseline）？"></a>什么是基线（baseline）？</h4><p><strong><code>小写字母x</code>的下边缘就是我们的基线</strong></p><blockquote><p>为什么会选小写字母x为基线，很容易想通，小写字母是轴对称图形，上下边都是平整的，而不是像s一样上下边是弯曲的。</p></blockquote><h5 id="扩展概念：x-height-1"><a href="#扩展概念：x-height-1" class="headerlink" title="扩展概念：x-height"></a>扩展概念：x-height</h5><p>定义：小写字母x的高度<br>扩展：尺寸单位ex是css中的一个相对单位，指的是小写字母x的高度（x-height）</p><h3 id="line-height（行高）-1"><a href="#line-height（行高）-1" class="headerlink" title="line-height（行高）"></a>line-height（行高）</h3><p>定义的就是两行基线的间距</p><h4 id="可能出现的值：-1"><a href="#可能出现的值：-1" class="headerlink" title="可能出现的值："></a>可能出现的值：</h4><ul><li>数值：所有的子元素继承的都是这个值</li><li>百分比或者长度值：所有的子元素继承的是最终的计算值</li></ul><blockquote><p>提示：内联元素span不能设置宽高，但支持line-height行高设置</p></blockquote><h3 id="line-height的好基友vertical-align-1"><a href="#line-height的好基友vertical-align-1" class="headerlink" title="line-height的好基友vertical-align"></a>line-height的好基友<code>vertical-align</code></h3><h4 id="vertical-align的属性值-1"><a href="#vertical-align的属性值-1" class="headerlink" title="vertical-align的属性值"></a>vertical-align的属性值</h4><ul><li>线类：baseline(default)/top/middle/bottom</li><li>文本类：text-top/text-bottom</li><li>上标下标类：sub/super</li><li>数值百分比类：20px/2em/20%(后面两个比较少用)</li></ul><h4 id="line-height-vertical-align-middle也只是近似的垂直居中-1"><a href="#line-height-vertical-align-middle也只是近似的垂直居中-1" class="headerlink" title="line-height+vertical-align:middle也只是近似的垂直居中"></a>line-height+vertical-align:middle也只是近似的垂直居中</h4><p><img src="/img/line-height/3.png"><br>middle是指沿着基线往上1/2 x-height高度对齐，可以近似理解为字母x交叉点的位置</p><blockquote><p>并不是绝对的居中对齐，因为不同的字体在行内盒子中的位置不一样，比如微软雅黑就是一个下沉比较明显的字体，所有字符的位置都比其他字体要偏下一点，字母x的交叉点是在容器中分线的下面一点。</p></blockquote><h4 id="vertical-align为一个数值来解决精确垂直居中的问题-1"><a href="#vertical-align为一个数值来解决精确垂直居中的问题-1" class="headerlink" title="vertical-align为一个数值来解决精确垂直居中的问题"></a>vertical-align为一个数值来解决精确垂直居中的问题</h4><p>vertical-align:baseline其实就是vertical-align:0<br>需要精确解决垂直居中的问题是需要在这个基础上进行调试的，比如设置vertical-align为-5px</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">vertical-align</span>:-<span class="hljs-number">5px</span>;<br></code></pre></td></tr></table></figure><p><img src="/img/line-height/4.png"></p><h4 id="注意点：-vertical-align作用条件-1"><a href="#注意点：-vertical-align作用条件-1" class="headerlink" title="注意点： vertical-align作用条件"></a>注意点： vertical-align作用条件</h4><p>可能会有人觉得vertical-align看似好用，但是有时候不起作用，但其实你需要知道它的使用条件：<strong>只能应用于内联元素以及display值为table-cell的元素</strong></p><h3 id="探索：display-flex-align-items-center能实现精确的文字垂直居中吗？-1"><a href="#探索：display-flex-align-items-center能实现精确的文字垂直居中吗？-1" class="headerlink" title="探索：display:flex+align-items:center能实现精确的文字垂直居中吗？"></a>探索：display:flex+align-items:center能实现精确的文字垂直居中吗？</h3><p>我们不如先来尝试下</p><p><img src="/img/line-height/5.png"><br>可以见得，万能的flex布局实现了文字垂直居中，但文字受到多种因素的影响，精确的垂直居中其实是比较难实现的。</p><h3 id="补充知识：div的高度是由行高决定的-1"><a href="#补充知识：div的高度是由行高决定的-1" class="headerlink" title="补充知识：div的高度是由行高决定的"></a>补充知识：div的高度是由行高决定的</h3><blockquote><ol><li>知识补充：替换元素（如image/video/input等这种替换某个属性就可以改变的元素）</li><li>行距 = line-height - font-size</li><li>半行距 = 行距 / 2</li></ol></blockquote><p>对于块级元素，line-height对其本身是没有任何作用的，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高实现的</p><ul><li>对于非替换元素的纯内联元素，其可视高度完全由line-height决定</li><li>纯文本：line-height决定最终高度</li><li>子元素含有替换元素，line-height只能决定最小高度<blockquote><p>原因：一是替换元素的高度不受line-height影响，二是vertical-align属性在背后作祟</p></blockquote></li></ul><h3 id="有意思的概念：幽灵空白节点-1"><a href="#有意思的概念：幽灵空白节点-1" class="headerlink" title="有意思的概念：幽灵空白节点"></a>有意思的概念：幽灵空白节点</h3><p><code>内联元素</code>的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。<br><code>透明</code>，<code>不占据任何宽度和高度</code>，就好像幽灵一样，看不见，却又确实撑开了父元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css"><span class="hljs-selector-tag">span</span> &#123;</span><br><span class="css">  <span class="hljs-attribute">display</span>:inline-block</span><br><span class="css">&#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/line-height/1.png"></p><blockquote><p>对幽灵空白节点的解释：可以认为在span元素的前面还有一个宽度为0的空白字符。</p></blockquote><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>其实对于前端来说，市面上常见的垂直居中方案是足以满足我们的需求的，有时候受到字体因素等的影响有略微差距其实也是可以接受的，只要你弄清楚它的原理或许你就不会这么困惑了。</p>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Flex布局的深度学习</title>
    <link href="/2021/07/21/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/flex/"/>
    <url>/2021/07/21/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/flex/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是Flex布局"><a href="#什么是Flex布局" class="headerlink" title="什么是Flex布局"></a>什么是Flex布局</h2><p>Flex 是 <code>Flexible Box</code> 的缩写，意为<code>&quot;弹性布局&quot;</code>，用来为盒状模型提供最大的灵活性。换句话说，你想要的任何布局灵活的flex基本都能帮你实现。</p><blockquote><p>任何一个父元素都可以指定为 Flex 布局。</p></blockquote><p>采用 Flex 布局的元素，称为 Flex 父元素（flex container），简称”父元素”。<br>它的所有子元素自动成为父元素成员，称为 Flex 子元素（flex item），简称”子元素”。<br><img src="/img/flex/0.png"></p><ul><li>父元素默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。</li><li>子元素默认沿主轴排列。单个子元素占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</li></ul><blockquote><p>这里的“父元素(container)”很多地方会直译为“容器”，个人认为叫“父元素”更通俗易懂，本文统称“父元素”，同理，其他地方“子元素（item）”会被直译为“项目”，本文统称“子元素”。</p></blockquote><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><p>与“主轴”垂直的轴称为“交叉轴”，通过对flex-direction的设定，主轴和交叉轴可以改变。</p><h2 id="父元素的属性-Flex-container"><a href="#父元素的属性-Flex-container" class="headerlink" title="父元素的属性(Flex-container)"></a>父元素的属性(Flex-container)</h2><p>以下6个属性设置在父元素上。</p><h3 id="一、flex-direction-方向"><a href="#一、flex-direction-方向" class="headerlink" title="一、flex-direction 方向"></a>一、flex-direction 方向</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">flex-direction: <span class="hljs-keyword">row</span>(<span class="hljs-keyword">default</span>) | <span class="hljs-keyword">row</span>-<span class="hljs-keyword">reverse</span> | <span class="hljs-keyword">column</span> | <span class="hljs-keyword">column</span>-<span class="hljs-keyword">reverse</span><br></code></pre></td></tr></table></figure><p>决定主轴的方向（即子元素的排列方向）</p><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。<br><img src="/img/flex/1.png"></li></ul><h3 id="二、flex-wrap-换行"><a href="#二、flex-wrap-换行" class="headerlink" title="二、flex-wrap 换行"></a>二、flex-wrap 换行</h3><p>默认情况下，子元素都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">flex-<span class="hljs-built_in">wrap</span>: nowrap(default) | <span class="hljs-built_in">wrap</span> | <span class="hljs-built_in">wrap</span>-<span class="hljs-built_in">reverse</span><br></code></pre></td></tr></table></figure><ul><li>nowrap（默认）：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><p><img src="/img/flex/2.png"></p><h3 id="三、flex-flow-流向"><a href="#三、flex-flow-流向" class="headerlink" title="三、flex-flow 流向"></a>三、flex-flow 流向</h3><p>flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><blockquote><p>简单理解 方向+换行一起决定了流向</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">flex-flow: <span class="hljs-tag">&lt;<span class="hljs-name">flex-direction</span>&gt;</span> || <span class="hljs-tag">&lt;<span class="hljs-name">flex-wrap</span>&gt;</span>;<br></code></pre></td></tr></table></figure><h3 id="四、justify-content-主轴对齐方式"><a href="#四、justify-content-主轴对齐方式" class="headerlink" title="四、justify-content 主轴对齐方式"></a>四、justify-content 主轴对齐方式</h3><p>属性定义了子元素在主轴上的对齐方式</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">justify-content: flex-start | flex-<span class="hljs-keyword">end</span> | center | <span class="hljs-literal">space</span>-<span class="hljs-keyword">between</span> | <span class="hljs-literal">space</span>-<span class="hljs-keyword">around</span>;<br></code></pre></td></tr></table></figure><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center： 居中</li><li>space-between：两端对齐，子元素之间的间隔都相等。</li><li>space-around：每个子元素两侧的间隔相等。所以，子元素之间的间隔比子元素与边框的间隔大一倍。</li></ul><h3 id="五、align-items-交叉轴对齐方式"><a href="#五、align-items-交叉轴对齐方式" class="headerlink" title="五、align-items 交叉轴对齐方式"></a>五、align-items 交叉轴对齐方式</h3><p>属性定义子元素在交叉轴上如何对齐</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">align-items: flex-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">baseline</span> | <span class="hljs-type">stretch</span>(default)<br></code></pre></td></tr></table></figure><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline: 子元素的第一行文字的基线对齐。</li><li>stretch（默认值）：如果子元素未设置高度或设为auto，将占满整个父元素的高度。</li></ul><h3 id="六、align-content-多行交叉轴对齐方式"><a href="#六、align-content-多行交叉轴对齐方式" class="headerlink" title="六、align-content 多行交叉轴对齐方式"></a>六、align-content 多行交叉轴对齐方式</h3><p>align-content属性定义了多根轴线的对齐方式。如果子元素只有一根轴线，该属性不起作用。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">align-content: flex-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">space</span>-between | <span class="hljs-type">space</span>-around | <span class="hljs-type">stretch</span>(default);<br></code></pre></td></tr></table></figure><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><h3 id="align-content-vs-align-items"><a href="#align-content-vs-align-items" class="headerlink" title="align-content vs align-items"></a>align-content vs align-items</h3><h4 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h4><p>都被用来设置对齐行为</p><h4 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h4><p>align-items 的设置对象是行内成员;<br><img src="/img/flex/3.png"><br>align-content 的设置对象是所有行，且只有在多行弹性盒子容器中才生效。<br><img src="/img/flex/4.png"></p><h2 id="子元素的属性"><a href="#子元素的属性" class="headerlink" title="子元素的属性"></a>子元素的属性</h2><p>以下6个属性设置在子元素上</p><h3 id="一、order-顺序"><a href="#一、order-顺序" class="headerlink" title="一、order 顺序"></a>一、order 顺序</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">order</span>: &lt;integer&gt;;<br></code></pre></td></tr></table></figure><p>属性定义子元素的排列顺序。数值越小，排列越靠前，默认为0。</p><h3 id="二、flex-grow-放大"><a href="#二、flex-grow-放大" class="headerlink" title="二、flex-grow 放大"></a>二、flex-grow 放大</h3><p>grow译翻译过来是生长，所以这个属性一定是和子元素的放大有关的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="父元素空间充足，子元素默认不变"><a href="#父元素空间充足，子元素默认不变" class="headerlink" title="父元素空间充足，子元素默认不变"></a>父元素空间充足，子元素默认不变</h4><p>flex-grow属性定义子元素的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。<br><strong>简单理解：子元素flex-grow的值越大所占比例越大</strong></p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>子元素默认是不会放大的，所以使用的场景是父元素空间充足时，子元素需要放大/子元素放大比例不一</p><blockquote><p>如果所有子元素的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个子元素的flex-grow属性为2，其他子元素都为1，则前者占据的剩余空间将比其他项多一倍。</p></blockquote><h3 id="三、flex-shrink-缩小"><a href="#三、flex-shrink-缩小" class="headerlink" title="三、flex-shrink 缩小"></a>三、flex-shrink 缩小</h3><p>shrink翻译过来是缩小，故这个属性一定是和子元素缩小有关的</p><h4 id="父元素空间不足，子元素默认等比缩小"><a href="#父元素空间不足，子元素默认等比缩小" class="headerlink" title="父元素空间不足，子元素默认等比缩小"></a>父元素空间不足，子元素默认等比缩小</h4><p>flex-shrink属性定义了子元素的缩小比例，默认为1，即如果空间不足，该子元素将缩小。</p><p><strong>简单理解：和flex-grow刚好相反，子元素flex-shrink的值越大所占比例越小</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>默认是会等比缩小的，所以使用的场景是空间不足时，子元素缩小比例不同/不需要缩小</p><blockquote><p>如果所有子元素的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个子元素的flex-shrink属性为0，其他子元素都为1，则空间不足时，前者不缩小。<br>负值对该属性无效。</p></blockquote><h3 id="四、flex-basis"><a href="#四、flex-basis" class="headerlink" title="四、flex-basis"></a>四、flex-basis</h3><p>flex-basis属性定义了在分配多余空间之前，子元素占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即子元素的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>它可以设为跟width或height属性一样的值（比如350px），则子元素将占据固定空间。</p><h3 id="五、flex"><a href="#五、flex" class="headerlink" title="五、flex"></a>五、flex</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//缩写记忆顺序为gsb</span><br>.<span class="hljs-class">item </span>&#123;<br><span class="hljs-symbol">  flex:</span> none | [ <span class="hljs-params">&lt;&#x27;flex-grow&#x27;&gt;</span> <span class="hljs-params">&lt;&#x27;flex-shrink&#x27;&gt;</span>? || <span class="hljs-params">&lt;&#x27;flex-basis&#x27;&gt;</span> ]<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="该属性的快捷值"><a href="#该属性的快捷值" class="headerlink" title="该属性的快捷值"></a>该属性的快捷值</h4><ul><li>auto (1 1 auto)</li><li>none (0 0 auto)</li><li>1 (1 1 0%)</li><li>0 (0 1 0%)</li></ul><h4 id="flex-auto和flex-1的区别"><a href="#flex-auto和flex-1的区别" class="headerlink" title="flex:auto和flex:1的区别"></a>flex:auto和flex:1的区别</h4><p>实际上就是flex-basis为0%和auto的区别,auto为默认值即为子元素的大小</p><ul><li>flex-basis为0%，可以覆盖width</li><li>flex-basis为auto，width权限更高</li></ul><blockquote><p>flex:auto=&gt;flex-basis:auto 表示flex-basis:$width 是相当于设置了Flex-basis为宽度的<br><img src="/img/flex/5.png"><br>flex:1=&gt;flex-basis:0 相当于未设置flex-basis<br><img src="/img/flex/6.png"></p></blockquote><h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>存在多余空间时，flex为1，width将会被忽略；flex为auto时，width的设置将是有效的</p><h3 id="六、align-self"><a href="#六、align-self" class="headerlink" title="六、align-self"></a>六、align-self</h3><p>align-self属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>单个子元素有与其他子元素有不一样的对齐方式</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coq">.item &#123;<br>  align-self: <span class="hljs-built_in">auto</span> | <span class="hljs-type">flex</span>-start | <span class="hljs-type">flex</span>-<span class="hljs-keyword">end</span> | <span class="hljs-type">center</span> | <span class="hljs-type">baseline</span> | <span class="hljs-type">stretch</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><blockquote><p><img src="/img/flex/7.png"></p></blockquote><h2 id="附：属性查询表（自制）"><a href="#附：属性查询表（自制）" class="headerlink" title="附：属性查询表（自制）"></a>附：属性查询表（自制）</h2><h3 id="父元素"><a href="#父元素" class="headerlink" title="父元素"></a>父元素</h3><p><img src="/img/flex/table1.png"></p><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><p><img src="/img/flex/table2.png"></p>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>Flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Fluid主题博客搭建</title>
    <link href="/2021/07/18/hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/07/18/hexo/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="我为什么选择Hexo-Fluid"><a href="#我为什么选择Hexo-Fluid" class="headerlink" title="我为什么选择Hexo-Fluid?"></a>我为什么选择Hexo-Fluid?</h3><p>目前个人博客搭建的方式众多，但最终的目的其实很简单，就是记录自己的技术学习历程，所以不想本末倒置浪费太多时间。我选择Hexo博客框架来搭建博客的主要原因如下：</p><ul><li>十分方便快捷，又能实现自适应，最重要的还是美观，让我有动力写下去</li><li>目前github上也有很多魔改Hexo框架的优秀例子，让我也很想尝试一把来打造属于自己的名片</li></ul><p>选择Fluid主题的起因其实也很纯粹，就是因为文档比较全面，维护情况也良好，让我能够高效且稳定的搭建自己的博客。</p><blockquote><p>之前在选择博客主题方面浪费很多时间，最终选择了某主题，但后期实际搭建和维护的时候查找资料浪费了大量时间，后期甚至启动的时候还遇到一些问题，还要自己去改源文件，让我无法很好的专注于写博客本身这件事，所以我十分明确高效简单稳定是我的第一需求。<br>后续在使用Fluid主题的时候，也更加坚定了自己这个选择，Fluid yyds!</p></blockquote><h3 id="博客搭建过程"><a href="#博客搭建过程" class="headerlink" title="博客搭建过程"></a>博客搭建过程</h3><p>首先献上Hexo官方文档和Fluid文档，建议食用顺序是先按照官方文档搭建出博客，然后再根据Fluid配置指南开始做配置了，后文将只会说一些我搭建时遇到的问题和解决方案，其他的文档里都写的很清楚了。</p><ul><li><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></li><li><a href="https://hexo.fluid-dev.com/docs">Fluid文档</a></li></ul><h4 id="编辑文件没有权限"><a href="#编辑文件没有权限" class="headerlink" title="编辑文件没有权限"></a>编辑文件没有权限</h4><p>我修改了文件的操作权限后仍有这个问题，terminal执行以下代码解决</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">sudo chmod -R <span class="hljs-number">777</span> . ## 为当前目录及子目录搜于读写权限<br></code></pre></td></tr></table></figure><h3 id="使用github-pages"><a href="#使用github-pages" class="headerlink" title="使用github pages"></a>使用github pages</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>创建一个新仓库，如果想使用<a href="https://username.github.io/">https://username.github.io</a>链接能直接进入博客的话，仓库名直接写username.github.io<br>但我比较想用另外的仓库来做为博客存放点，所以我建了一个名为blog的仓库,但这个决定让我遇到了一些问题，因为在_config.yml的配置不对，导致我编译出的文件引用路径不对，样式错乱，下面展示下正确的配置</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">url:</span> https:<span class="hljs-comment">//username.github.io/blog</span><br><span class="hljs-symbol">root:</span> /blog<br></code></pre></td></tr></table></figure><h4 id="search功能检查"><a href="#search功能检查" class="headerlink" title="search功能检查"></a>search功能检查</h4><p>如果通过blog子页面去访问github pages,注意修改下search页面路径为blog仓库下的，不然搜索时会因为找不到搜索页持续loading</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">search:</span><br>  <span class="hljs-meta"># 搜索索引文件的路径，可以是相对路径或外站的绝对路径</span><br>  <span class="hljs-meta"># 如果后续修改为自定义域名后记得把/blog前缀去掉</span><br><span class="hljs-symbol">  path:</span> <span class="hljs-meta-keyword">/blog/</span>local-search.xml<br></code></pre></td></tr></table></figure><h4 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h4><p>如果后期你想改用github pages自定义域名的话，url写自己的域名就好，root这一行记得注释掉</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">ur<span class="hljs-variable">l:</span> http<span class="hljs-variable">s:</span>//blog.strugglinglee.<span class="hljs-keyword">cn</span><br># roo<span class="hljs-variable">t:</span> /blog<br></code></pre></td></tr></table></figure><p>我这里顺带说下配置自定义域名的方法，如下图，setting-&gt;pages-&gt;custom domain<br><img src="/img/hexo/1.png"><br>这里比较建议用子域名，添加一条dns解析记录即可，我使用的是腾讯云，其他运营商应该也是类似的，主机记录填写blog，记录类型选择CHAME,记录值为github page的域名<br><img src="/img/hexo/2.png"></p><p>目前配置ssl证书使用https安全链接访问也比较方便，一般运营商都可以支持一键申请和部署，不需要做太多操作，记得提前备案你的网站。</p><h3 id="如何修改配置"><a href="#如何修改配置" class="headerlink" title="如何修改配置"></a>如何修改配置</h3><p>修改配置这里我走了比较多的弯路，习惯于google，很是浪费时间，这边建议搭配fluid文档和<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml</a>来修改配置</p><p>比如我想修改网站的favicon小图标，直接在_config.yml文件中ctrl+f来搜索favicon，把这两行复制到自己的yml文件中再进行修改，就可以覆盖默认配置，真香。<br><img src="/img/hexo/3.png"></p><blockquote><p>_config.yml可以自己看一遍，对一些基础配置有个了解会比较方便后续你修改。</p></blockquote><h3 id="自动编译部署"><a href="#自动编译部署" class="headerlink" title="自动编译部署"></a>自动编译部署</h3><h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><p>我这边是用到了hexo官方推荐的travis-ci第三方自动编译部署<a href="https://hexo.io/zh-cn/docs/github-pages">链接自取</a><br><img src="/img/hexo/4.png"><br>按配置一步步来就好，配好了就十分简单了，push上去直接部署</p><h4 id="编译问题处理"><a href="#编译问题处理" class="headerlink" title="编译问题处理"></a>编译问题处理</h4><p>我按官方给的yml文件配置部署有时候会存在缓存文件未更新的情况，或者下面这些yarn报错的问题</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">The</span> command <span class="hljs-string">&quot;yarn&quot;</span> failed and exited with <span class="hljs-number">1</span> during .<br><span class="hljs-attribute">The</span> command <span class="hljs-string">&quot;eval yarn --frozen-lockfile &quot;</span> failed. Retrying, <span class="hljs-number">2</span> of <span class="hljs-number">3</span>.<br></code></pre></td></tr></table></figure><p>这里贴一下我自己修改后的yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sudo:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;14&quot;</span> <span class="hljs-comment"># use nodejs v14 LTS 解决yarn报错问题</span><br><span class="hljs-attr">cache:</span> <span class="hljs-string">npm</span><br><span class="hljs-attr">branches:</span><br>  <span class="hljs-attr">only:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">main</span> <span class="hljs-comment"># build master branch only</span><br><span class="hljs-attr">install:</span> <span class="hljs-comment"># 解决yarn报错问题</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">yarn</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">clean</span> <span class="hljs-comment"># 解决缓存文件未更新问题</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">hexo</span> <span class="hljs-string">generate</span> <span class="hljs-comment"># generate static files</span><br><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">provider:</span> <span class="hljs-string">pages</span><br>  <span class="hljs-attr">skip-cleanup:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">github-token:</span> <span class="hljs-string">$GH_TOKEN</span><br>  <span class="hljs-attr">keep-history:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">on:</span><br>    <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br>  <span class="hljs-attr">local-dir:</span> <span class="hljs-string">public</span><br></code></pre></td></tr></table></figure><p>travis-ci还是挺稳定的，编译部署也很快，个人还是比较推荐的。后续又了解到了github自家的Github Actions，都是免费的，决定抽时间也玩玩。</p><h3 id="自定义iconfont使用"><a href="#自定义iconfont使用" class="headerlink" title="自定义iconfont使用"></a>自定义iconfont使用</h3><p><a href="https://hexo.fluid-dev.com/docs/icon/#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87">官方配置自定义iconfont文档</a></p><h4 id="使用流程参考"><a href="#使用流程参考" class="headerlink" title="使用流程参考"></a>使用流程参考</h4><p>可以看到官方文件是使用伪元素这样处理iconfont的<br><img src="/img/hexo/5.png"><br>没有什么实际参考意义，我们实际上可以通过background来处理就好，比如我想使用一个掘金的小图标来放到关于页面，具体步骤如下</p><ol><li>在source文件夹下建了一个css文件夹并且新建一个custom.css文件</li><li>在_config.fluid.yml文件中添加这行代码 custom_css: /css/custom.css</li><li>在css文件中贴入类似如下的代码 <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 1c">.icon-juejin-fill &#123;<br>  display: inline-block;<br>  width: <span class="hljs-number">24</span>px;<br>  height: <span class="hljs-number">26</span>px;<br>  background: url(&#x27;data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F<span class="hljs-number">2000</span>%2Fsvg%22%20width%3D%<span class="hljs-number">2224</span>%22%20height%3D%<span class="hljs-number">2224</span>%22%20viewBox%3D%220%200%<span class="hljs-number">2031</span>%<span class="hljs-number">2024</span>%22%20fill%3D%22none%22%3E%3Cpath%20fill-rule%3D%22evenodd%22%20clip-rule%3D%22evenodd%22%20d%3D%22M15.<span class="hljs-number">0737</span>%205.<span class="hljs-number">8039</span>6H15.<span class="hljs-number">0757</span>L18.706%202.<span class="hljs-number">9172</span>2L15.<span class="hljs-number">0757</span>%200.<span class="hljs-number">00406298</span>L15.<span class="hljs-number">0717</span>%200L11.<span class="hljs-number">4475</span>%202.<span class="hljs-number">9111</span>2L15.<span class="hljs-number">0717</span>%205.<span class="hljs-number">8019</span>3L15.<span class="hljs-number">0737</span>%205.<span class="hljs-number">8039</span>6ZM15.<span class="hljs-number">0757</span>%<span class="hljs-number">2014.9111</span>L15.<span class="hljs-number">0778</span>%<span class="hljs-number">2014.9091</span>L24.<span class="hljs-number">4429</span>%207.<span class="hljs-number">5205</span>7L21.<span class="hljs-number">9036</span>%205.<span class="hljs-number">4809</span>6L15.<span class="hljs-number">0778</span>%<span class="hljs-number">2010.8664</span>L15.<span class="hljs-number">0757</span>%<span class="hljs-number">2010.8685</span>L15.<span class="hljs-number">0737</span>%<span class="hljs-number">2010.8705</span>L8.<span class="hljs-number">2479</span>%205.<span class="hljs-number">4850</span>2L5.<span class="hljs-number">7105</span>7%207.<span class="hljs-number">5246</span>3L15.<span class="hljs-number">0737</span>%<span class="hljs-number">2014.9132</span>L15.<span class="hljs-number">0757</span>%<span class="hljs-number">2014.9111</span>ZM15.<span class="hljs-number">0716</span>%<span class="hljs-number">2019.9614</span>L15.<span class="hljs-number">0757</span>%<span class="hljs-number">2019.9593</span>L27.614%<span class="hljs-number">2010.06</span>6L30.<span class="hljs-number">1534</span>%<span class="hljs-number">2012.1056</span>L24.449%<span class="hljs-number">2016.6053</span>L15.<span class="hljs-number">0757</span>%<span class="hljs-number">2024</span>L0.<span class="hljs-number">243779</span>%<span class="hljs-number">2012.3047</span>L0%<span class="hljs-number">2012.1117</span>L2.<span class="hljs-number">5393</span>6%<span class="hljs-number">2010.0721</span>L15.<span class="hljs-number">0716</span>%<span class="hljs-number">2019.9614</span>Z%22%20fill%3D%22%231E80FF%22%2F%3E%3C%2Fsvg%3E&#x27;) no-repeat center <span class="hljs-number">4</span>px;<br>  background-size: <span class="hljs-number">100</span>%;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>i标签通过class来引用就ok</li></ol><blockquote><p>注意svg文件需要通过encodeURIComponent方法来编码下，不然会有兼容问题，部分机型会看不到，比如我这边mac就会出现图标消失的问题</p></blockquote><h3 id="评论插件的选择"><a href="#评论插件的选择" class="headerlink" title="评论插件的选择"></a>评论插件的选择</h3><p><a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">评论配置文档入口</a></p><p>其实fluid官方已经做了很多评论插件的支持，根据其给出的参考文档链接就能快速方便的进行配置<br>通过在<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml</a>文件中搜索对应的关键字把相关的配置copy过来进行填写就好。</p><p><img src="/img/hexo/6.png"></p><p>尝试了很多，我个人比较喜欢极简方便快捷的，所以我选择了Valine，顺带提一句，Twikoo (基于腾讯云开发)其实看起来也特好用，输入自己的qq邮箱还能自动生成自己的qq头像，但是不是免费的，嗯，向金钱低头。<br>btw，免费的Valine已经很香了，如下图。</p><p><img src="/img/hexo/7.png"></p><p>以上，就是我近期对Hexo-Fluid的初步尝试，也算是初见成效，写文章也更有动力了。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><p>遇到问题，解决问题的过程很煎熬，但是只要不停的尝试，成功的那一刻是难以言喻的。另外深刻体会到一点就是任何事情在最开始的时候最不能偷懒，必须先有一个全局的规划，多方对比选择最适合的方案，不然只会是不停的浪费时间，不停的撞南墙。只要走上一条正确的路，加上坚持，虽然过程中也会有些许磕绊，但最后成功之后便都是收获。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解可选链和Null 判断运算符</title>
    <link href="/2020/09/23/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/es6+/%E5%8F%AF%E9%80%89%E9%93%BE%E5%92%8C%E5%8F%8C%E9%97%AE%E5%8F%B7/"/>
    <url>/2020/09/23/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/es6+/%E5%8F%AF%E9%80%89%E9%93%BE%E5%92%8C%E5%8F%8C%E9%97%AE%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://es6.ruanyifeng.com/#docs/operator">参考：阮一峰ES6教程</a></p></blockquote><h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>之前我们访问可能不存在的对象属性，通常会使用这样的方法</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> nestedProp = obj.<span class="hljs-built_in">first</span> &amp;&amp; obj.<span class="hljs-built_in">first</span>.<span class="hljs-built_in">second</span>;<br></code></pre></td></tr></table></figure><p>可选链可以简化这样的写法，下面我们来了解一下什么是可选链</p><h3 id="可选链操作符"><a href="#可选链操作符" class="headerlink" title="可选链操作符 ?."></a>可选链操作符 <code>?.</code></h3><p>1.允许读取位于链接对象链深处的属性的值<br>2.不必明确验证链中每个引用是否有效<br>3.类似于.链式操作符，不同之处在于，在引用为空（null/undefined）的情况下不会因其错误，该表达式短路返回值式undefined<br>4.与函数调用一起使用时，如果给定的函数不存在，则返回undefined</p><h3 id="常用写法"><a href="#常用写法" class="headerlink" title="常用写法"></a>常用写法</h3><p>通过连接的对象的引用或函数可能是 undefined 或 null 时，可选链操作符提供了一种方法来简化被连接对象的值访问。</p><h3 id="可选链与函数调用"><a href="#可选链与函数调用" class="headerlink" title="可选链与函数调用"></a>可选链与函数调用</h3><p>函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回undefined而不是抛出一个异常</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">let</span> <span class="hljs-literal">result</span>=someInterface.customMethod?()<br></code></pre></td></tr></table></figure><h3 id="可选链不能用于赋值"><a href="#可选链不能用于赋值" class="headerlink" title="可选链不能用于赋值"></a>可选链不能用于赋值</h3><p><del>object?.property=1</del></p><h3 id="连用可选链操作符"><a href="#连用可选链操作符" class="headerlink" title="连用可选链操作符"></a>连用可选链操作符</h3><p>let duration=vacations.trip?.getTime?.()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">a?.b<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a.b<br><br>a?.[x]<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a[x]<br><br>a?.b()<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a.b()<br><br>a?.()<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a()<br></code></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol><li>短路机制</li></ol><p>本质上，?.运算符相当于一种短路机制，只要不满足条件，就不再往下执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">a?.[++x]<br><span class="hljs-comment">// 等同于</span><br>a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a[++x]<br></code></pre></td></tr></table></figure><p>上面代码中，如果a是undefined或null，那么x不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p><ol start="2"><li>括号的影响</li></ol><p>如果属性链有圆括号，链判断运算符对圆括号外部没有影响，只对圆括号内部有影响。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">(a?.b).c<br><span class="hljs-comment">// 等价于</span><br>(a == <span class="hljs-literal">null</span> ? <span class="hljs-literal">undefined</span> : a.b).c<br></code></pre></td></tr></table></figure><p>上面代码中，?.对圆括号外部没有影响，不管a对象是否存在，圆括号后面的.c总是会执行。</p><p>一般来说，使用?.运算符的场合，不应该使用圆括号。</p><ol start="3"><li>报错场合</li></ol><p>以下写法是禁止的，会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">new</span> a?.()<br><span class="hljs-keyword">new</span> a?.b()<br><br><span class="hljs-comment">// 链判断运算符的右侧有模板字符串</span><br>a?.<span class="hljs-string">`&#123;b&#125;`</span><br>a?.b<span class="hljs-string">`&#123;c&#125;`</span><br><br><span class="hljs-comment">// 链判断运算符的左侧是 super</span><br><span class="hljs-built_in">super</span>?.()<br><span class="hljs-built_in">super</span>?.foo<br><br><span class="hljs-comment">// 链运算符用于赋值运算符左侧</span><br>a?.b = c<br></code></pre></td></tr></table></figure><ol start="4"><li>右侧不得为十进制数值</li></ol><p>为了保证兼容以前的代码，允许foo?.3:0被解析成foo ? .3 : 0，因此规定如果?.后面紧跟一个十进制数字，那么?.不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p><h2 id="Null-判断运算符（-双问号）"><a href="#Null-判断运算符（-双问号）" class="headerlink" title="Null 判断运算符（??双问号）"></a>Null 判断运算符（??双问号）</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>读取对象属性的时候，如果某个属性的值是null或undefined，有时候需要为它们指定默认值。常见做法是通过||运算符指定默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> headerText = response.settings.headerText || <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br><span class="hljs-keyword">const</span> animationDuration = response.settings.animationDuration || <span class="hljs-number">300</span>;<br><span class="hljs-keyword">const</span> showSplashScreen = response.settings.showSplashScreen || <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>上面的三行代码都通过||运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p><p>为了避免这种情况，ES2020 引入了一个新的 <strong>Null 判断运算符??<strong>。它的行为类似||，但是</strong>只有运算符左侧的值为null或undefined时</strong>，才会返回右侧的值。</p><h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> headerText = response.settings.headerText ?? <span class="hljs-string">&#x27;Hello, world!&#x27;</span>;<br><span class="hljs-keyword">const</span> animationDuration = response.settings.animationDuration ?? <span class="hljs-number">300</span>;<br><span class="hljs-keyword">const</span> showSplashScreen = response.settings.showSplashScreen ?? <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>上面代码中，默认值只有在左侧属性值为null或undefined时，才会生效。</strong></p><p><strong>这个运算符的一个目的，就是跟链判断运算符?.配合使用，为null或undefined的值设置默认值。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> animationDuration = response.settings?.animationDuration ?? <span class="hljs-number">300</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，如果response.settings是null或undefined，或者response.settings.animationDuration是null或undefined，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。</p><p>这个运算符很适合判断函数参数是否赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> enable = props.enabled ?? <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码判断props参数的enabled属性是否赋值，基本等同于下面的写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;<br>    <span class="hljs-attr">enabled</span>: enable = <span class="hljs-literal">true</span>,<br>  &#125; = props;<br>  <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>??本质上是逻辑运算，它与其他两个逻辑运算符&amp;&amp;和||有一个优先级问题，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。</p><p>现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 报错</span><br>lhs &amp;&amp; middle ?? rhs<br>lhs ?? middle &amp;&amp; rhs<br>lhs || middle ?? rhs<br>lhs ?? middle || rhs<br>上面四个表达式都会报错，**必须加入表明优先级的括号**。<br><br>(lhs &amp;&amp; middle) ?? rhs;<br>lhs &amp;&amp; (middle ?? rhs);<br><br>(lhs ?? middle) &amp;&amp; rhs;<br>lhs ?? (middle &amp;&amp; rhs);<br><br>(lhs || middle) ?? rhs;<br>lhs || (middle ?? rhs);<br><br>(lhs ?? middle) || rhs;<br>lhs ?? (middle || rhs);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>es6+</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6+</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.0发布后的一点总结</title>
    <link href="/2020/09/20/vue/vue3.0%E5%8F%91%E5%B8%83%E5%90%8E%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2020/09/20/vue/vue3.0%E5%8F%91%E5%B8%83%E5%90%8E%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="分离内部模块"><a href="#分离内部模块" class="headerlink" title="分离内部模块"></a>分离内部模块</h3><ul><li>vue3.0的核心仍然是通过一个简单的<code>&lt;script /&gt;</code>标签来使用，但其内部结构已经被重写，并解耦成一个个模块的集合</li><li>允许终端用户通过tree-shaking的形式将减少一半运行时的体积<blockquote><ul><li><a href="https://webpack.docschina.org/guides/tree-shaking/">tree shaking</a> ，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)</li><li>运行时<a href="https://webpack.docschina.org/concepts/manifest/">rumtime</a></li></ul></blockquote></li><li>这些模块还暴露了底层api，解锁了许多高级用法</li></ul><h3 id="引入Composition-API"><a href="#引入Composition-API" class="headerlink" title="引入Composition API"></a>引入Composition API</h3><blockquote><p><a href="https://vue-composition-api-rfc.netlify.app/zh/#%E6%A6%82%E8%BF%B0">Composition API RFC传送门</a></p></blockquote><h4 id="什么是Composition-API"><a href="#什么是Composition-API" class="headerlink" title="什么是Composition API"></a>什么是Composition API</h4><ul><li>一套全新的 API，旨在解决 Vue 在大规模应用场景中的痛点。</li><li>Composition API 构建于响应式 API 之上，实现了类似于 React hook 的逻辑组成与复用，相较于 2.x 基于对象的 API 方式来说，拥有更加灵活的代码组织模式，以及更为可靠的类型推断能力。</li></ul><h3 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h3><h4 id="Vue-3-与-Vue-2-相比有着显著的性能提升"><a href="#Vue-3-与-Vue-2-相比有着显著的性能提升" class="headerlink" title="Vue 3 与 Vue 2 相比有着显著的性能提升"></a>Vue 3 与 Vue 2 相比有着显著的性能提升</h4><ul><li>在 <strong>bundle 包大小</strong>方面（tree-shaking 减少了 41%的体积）</li><li><strong>初始渲染速度</strong>方面（快了 55%）</li><li><strong>更新速度</strong>方面（快了 133%）</li><li><strong>内存占用</strong>方面（减少了 54%）</li></ul><h4 id="编译信息虚拟-DOM"><a href="#编译信息虚拟-DOM" class="headerlink" title="编译信息虚拟 DOM"></a>编译信息虚拟 DOM</h4><ul><li>在 3.0 中，采取了 “编译信息虚拟 DOM” 的方式：针对模板编译器进行了优化，并生成渲染函数代码，以提升静态内容的渲染性能，为绑定类型留下运行时提示，最为重要的是，模板内部的动态节点进行了扁平化处理，以减少运行时遍历的开销。</li><li>因此，用户可以获得两全其美的效果，从模板中获得编译器优化后的性能，或在需要时通过手动渲染函数直接控制。</li></ul><h3 id="改进与-TypeScript-的兼容"><a href="#改进与-TypeScript-的兼容" class="headerlink" title="改进与 TypeScript 的兼容"></a>改进与 TypeScript 的兼容</h3><ul><li>Vue 3 的代码库完全采用 TypeScript 编写，自动生成、测试并构建类型声明，因此它们总为最新。</li><li>Composition API 可以很好的进行类型推断。Vetur，官方推出的 VSCode 插件，现已支持对模板表达式和 props 的类型检查</li><li>同时，Vue 3 已全面支持 TSX</li></ul><h3 id="为单文件组件提出了两个新特性"><a href="#为单文件组件提出了两个新特性" class="headerlink" title="为单文件组件提出了两个新特性"></a>为单文件组件提出了两个新特性</h3><blockquote><p><code>SFC（.vue文件）</code></p></blockquote><ul><li><p><code>&lt;script setup&gt;</code>：在 SFC 内使用 Composition API 的语法糖</p><blockquote><p>这个上文已经有提及</p></blockquote></li><li><p><code>&lt;style vars&gt;</code>：在 SFC 中支持将状态作为 CSS 变量注入到样式</p><blockquote><ul><li>CSS本身有很多缺陷，所以才会有后面各种预处理器的出现，这些预处理器中有个非常重要的特性就是<code>变量</code></li><li>这次版本更新之前，我们更多的是直接来操作dom或者直接通过变量来控制内联样式去动态改变样式，这样处理并不优雅，也会浪费一些性能</li><li>提示一下，这个新特性暂时还不兼容IE11，但是指日可待啦：）</li></ul></blockquote></li></ul><p>版本更新之后我们就能在style里通过vars=””来获取我们在js中声明的变量</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml">//比较简单的玩法</span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">color</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">  data () &#123;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span></span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml">  &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">vars</span>=<span class="hljs-string">&quot;&#123; color ,..... &#125;&quot;</span>&gt;</span><span class="css"></span></span><br><span class="css"><span class="xml"><span class="hljs-selector-tag">h1</span> &#123;</span></span><br><span class="css"><span class="xml">  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--color);</span></span><br><span class="css"><span class="xml">&#125;</span></span><br><span class="css"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br><span class="xml"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3.0</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git学习</title>
    <link href="/2020/09/20/git/git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/09/20/git/git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>git官方文档<br><strong>git</strong> 设置个⼈人姓名 <strong>/</strong> 邮箱(全局)</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git config --global user.<span class="hljs-keyword">name</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">2 </span>git config --global user/email <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>版本库 = 仓库 repository= ⽬目录，其中的所有的⽂文件都可以被 git 管理理起来，每个⽂文件的修改 / 删除， git 都能跟踪</p><h2 id="将⽬目录变成-git-可以管理理的仓库"><a href="#将⽬目录变成-git-可以管理理的仓库" class="headerlink" title="将⽬目录变成 git 可以管理理的仓库"></a>将⽬目录变成 git 可以管理理的仓库</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git init<br></code></pre></td></tr></table></figure><h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><p>git reset –hard<br>HEAD 当前版本<br>HEAD^ 上⼀一个版本<br>HEAD^^ 上上个版本<br>HEAD~n 往上n个版本</p><p>reset 回退之后的重新找回操作</p><p>1 git reset –hard ${commit_id}<br>如果不不知道commit_id-使⽤用git reflog查看<br>git reflog -查看命令历史</p><p>git和其他版本控制系统如svn的⼀一个不不同之处就是会有暂存区的概念</p><p>Git⽐比其他管理理版本控制系统设计得更更优秀的原因-git跟踪并管理理的是修改，⽽而⾮非⽂文件</p><h1 id="差异比较"><a href="#差异比较" class="headerlink" title="差异比较"></a>差异比较</h1><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p><strong>git diff HEAD – readme.txt</strong> ⽐比较⼯工作区和版本库⾥里里⾯面最新版本的区别</p><h1 id="清理理并未提交的内容"><a href="#清理理并未提交的内容" class="headerlink" title="清理理并未提交的内容"></a>清理理并未提交的内容</h1><h3 id="没有提交到暂存区"><a href="#没有提交到暂存区" class="headerlink" title="没有提交到暂存区"></a>没有提交到暂存区</h3><p><strong>git checkout – <code>&lt;file&gt;</code></strong></p><h3 id="已经提交到暂存区"><a href="#已经提交到暂存区" class="headerlink" title="已经提交到暂存区"></a>已经提交到暂存区</h3><p><strong>git reset HEAD <code>&lt;file&gt;</code></strong></p><h1 id="删除⽂件"><a href="#删除⽂件" class="headerlink" title="删除⽂件"></a>删除⽂件</h1><p>1 git rm <code>&lt;file&gt;</code><br>恢复误删⽂文件</p><p>1 git checkout – <code>&lt;file&gt;</code><br>从来没有被添加到版本库就被删除的⽂文件，是⽆无法恢复的</p><h1 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h1><h2 id="git-reflog-查看历史版本记录"><a href="#git-reflog-查看历史版本记录" class="headerlink" title="git reflog- 查看历史版本记录"></a>git reflog- 查看历史版本记录</h2><p>每⾏行行记录都由版本号（ <strong>commit id SHA</strong> ）， <strong>HEAD</strong> 值和操作描述三部分组成。<br>版本号在第⼀一列列，HEAD值在第⼆二列列，操作描述信息在第三列列。<br>版本号：标识着每⼀一次提交、合并等操作时的版本，相当于唯⼀一标识<br><strong>HEAD</strong> 值：同样⽤用来标识版本，但是不不同于版本号的是，Head值是相对的。当HEAD值为HEAD时，表示为提交的最新版本；HEAD^表<br>示为最新版本的上⼀一个版本；HEAD^^表示为最新版本的上上个版本；HEAD~100表示为最新版本的往上第 100 个版本。HEAD值越⼩小，<br>表示版本越新，越⼤大表示版本⽣生成时间越久。<br>在上面图中，我们发现HEAD值的展示形式为HEAD@{0}、HEAD@{1}、HEAD@{2}…同样HEAD值的数字越小，表示版本越新，<br>数字越大表示版本越旧。<br>操作描述：记录了了本次是哪种操作，以及操作时编写的描述信息。</p><h2 id="git-reflog-n-查看历史版本记录-–-指定显示条数"><a href="#git-reflog-n-查看历史版本记录-–-指定显示条数" class="headerlink" title="git reflog -n 查看历史版本记录 – 指定显示条数"></a>git reflog -n 查看历史版本记录 – 指定显示条数</h2><h2 id="可以救命的-git-reflog"><a href="#可以救命的-git-reflog" class="headerlink" title="可以救命的 git reflog"></a>可以救命的 git reflog</h2><p>当你不不⼩小⼼心reset –hard之后可以通过git reflog看到所有的操作，执⾏行行git reset –hard 命令可以回到之前的状态</p><h1 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h1><p><strong>–soft</strong> 回退后a分⽀支修改的代码被保留留并标记为add的状态（git status 是绿⾊色的状态）<br><strong>–mixed</strong> 重置索引，但不不重置⼯工作树，更更改后的⽂文件标记为未提交（add）的状态。默认操作。<br><strong>–hard</strong> 重置索引和⼯工作树，并且 <strong>a</strong> 分⽀支修改的所有⽂文件和中间的提交，没提交的代码都被丢弃了了。<br><strong>–merge</strong> 和–hard类似，只不不过如果在执⾏行行reset命令之前你有改动⼀一些⽂文件并且未提交，merge会保留留你的这些修改，hard则不不会。<br>【注：如果你的这些修改add过或commit过，merge和hard都将删除你的提交】<br><strong>–keep</strong> 和–hard类似，执⾏行行reset之前改动⽂文件如果是a分⽀支修改了了的，会提示你修改了了相同的⽂文件，不不能合并。如果不不是a分⽀支修改<br>的⽂文件，会移除缓存区。git status还是可以看到保持了了这些修改。</p><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><h2 id="git-revert操作之后，network中还是可以看到a分⽀支和合并a分⽀支的操作，只不不过在其基础上⼜又增加了了⼀一个revert的commit⽽已"><a href="#git-revert操作之后，network中还是可以看到a分⽀支和合并a分⽀支的操作，只不不过在其基础上⼜又增加了了⼀一个revert的commit⽽已" class="headerlink" title="git revert操作之后，network中还是可以看到a分⽀支和合并a分⽀支的操作，只不不过在其基础上⼜又增加了了⼀一个revert的commit⽽已"></a>git revert操作之后，network中还是可以看到a分⽀支和合并a分⽀支的操作，只不不过在其基础上⼜又增加了了⼀一个revert的commit⽽已</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git revert -m <span class="hljs-comment">&#x27;msg&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="创建-SSH-key-公钥-的命令"><a href="#创建-SSH-key-公钥-的命令" class="headerlink" title="创建 SSH key (公钥)的命令"></a>创建 SSH key (公钥)的命令</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><h1 id="拷⻉贝⽣生成公钥的命令"><a href="#拷⻉贝⽣生成公钥的命令" class="headerlink" title="拷⻉贝⽣生成公钥的命令"></a>拷⻉贝⽣生成公钥的命令</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>pbcopy &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><h1 id="git-amend-⽤用法"><a href="#git-amend-⽤用法" class="headerlink" title="git amend ⽤用法"></a>git amend ⽤用法</h1><h2 id="修改最后一次提交"><a href="#修改最后一次提交" class="headerlink" title="修改最后一次提交"></a>修改最后一次提交</h2><h2 id="1-git-commit-–-amend-–-no-edit，不不⽤用重新编辑提交信息"><a href="#1-git-commit-–-amend-–-no-edit，不不⽤用重新编辑提交信息" class="headerlink" title="1.git commit –-amend –-no-edit，不不⽤用重新编辑提交信息"></a>1.git commit –-amend –-no-edit，不不⽤用重新编辑提交信息</h2><h2 id="2-git-commit-–amend-m-“msg”-重新编辑提交信息"><a href="#2-git-commit-–amend-m-“msg”-重新编辑提交信息" class="headerlink" title="2.git commit –amend -m “msg” ,重新编辑提交信息"></a>2.git commit –amend -m “msg” ,重新编辑提交信息</h2><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="先有本地库，后有远程库的时候，关联远程库"><a href="#先有本地库，后有远程库的时候，关联远程库" class="headerlink" title="先有本地库，后有远程库的时候，关联远程库"></a>先有本地库，后有远程库的时候，关联远程库</h2><p>1.在github上⾯面创建⼀一个仓库<br>2.关联远程库，使⽤用命令</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git <span class="hljs-comment">remote add origin git@github.com:**/learngit.git</span><br></code></pre></td></tr></table></figure><p>origin 远程仓库的名字 –git的默认叫法<br>3.将本地库所有内容推送到远程库上</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git push -u origin master<br></code></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">第一次推送<span class="hljs-literal">master</span>分支时，加了-u参数，git会把本地的分支内容推送到远程新的<span class="hljs-literal">master</span>分支，而且会把本地的<span class="hljs-literal">master</span>分支和远程的<br><span class="hljs-literal">master</span>分支关联起来<br></code></pre></td></tr></table></figure><h2 id="先创建远程库，然后，从远程库中克隆隆"><a href="#先创建远程库，然后，从远程库中克隆隆" class="headerlink" title="先创建远程库，然后，从远程库中克隆隆"></a>先创建远程库，然后，从远程库中克隆隆</h2><h3 id="1-⾸首先要拿到仓库地址"><a href="#1-⾸首先要拿到仓库地址" class="headerlink" title="1.⾸首先要拿到仓库地址"></a>1.⾸首先要拿到仓库地址</h3><p>2.使⽤用git clone命令克隆隆</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git支持多种协议，包括<span class="hljs-keyword">https</span>，但ssh协议速度最快<br></code></pre></td></tr></table></figure><h1 id="分⽀支管理理"><a href="#分⽀支管理理" class="headerlink" title="分⽀支管理理"></a>分⽀支管理理</h1><h2 id="创建与合并分⽀支"><a href="#创建与合并分⽀支" class="headerlink" title="创建与合并分⽀支"></a>创建与合并分⽀支</h2><p>git checkout 加上-b参数表示创建并切换，相当于</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git branch dev<br><span class="hljs-symbol">2 </span>git checkout dev<br></code></pre></td></tr></table></figure><p>git merge命令-⽤用于合并指定分⽀支到当前分⽀支<br>fast-forward-快进模式，也就是直接把master指向dev的当前分支，所以合并速度非常快</p><h2 id="git-switch-vs-git-checkout"><a href="#git-switch-vs-git-checkout" class="headerlink" title="git switch vs git checkout"></a>git switch vs git checkout</h2><h3 id="有两个容易混淆的命令"><a href="#有两个容易混淆的命令" class="headerlink" title="有两个容易混淆的命令"></a>有两个容易混淆的命令</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">1.切换分支使用git checkout <span class="hljs-tag">&lt;<span class="hljs-name">branch</span>&gt;</span><br>2.撤销修改则是git checkout --<span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span><br>所以最新版本的git提供了新的git switch 命令来切换分支<br></code></pre></td></tr></table></figure><p>1.创建并切换到新的dev分⽀支</p><p>1 git switch - c dev<br>2.直接切换到已有的master分⽀支</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git switch master<br></code></pre></td></tr></table></figure><p>⼩小结：</p><ol><li>查看分⽀支：git branch</li></ol><p><strong>2.</strong> 创建分⽀支： <strong>git branch <code>&lt;name&gt;</code><br>3.</strong> 切换分⽀支： <strong>git checkout <code>&lt;name&gt;</code></strong> 或者 <strong>git switch <name><br>4.</strong> 创建 <strong>+</strong> 切换分⽀支： <strong>git checkout -b <code>&lt;name&gt;</code></strong> 或者 <strong>git switch -c <code>&lt;name&gt;</code></strong><br>5. 合并某分⽀支到当前分⽀支：git merge <code>&lt;name&gt;</code><br>6. 删除分⽀支：git branch -d <code>&lt;name&gt;</code><br>7. 删除某个分⽀支以外的分⽀支<br>1 git branch | grep -v “master” | xargs git branch -D</p><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><ol><li>当Git⽆无法⾃自动合并分⽀支时，就必须⾸首先解决冲突</li><li>解决冲突后，再提交，合并完成。</li></ol><p>解决冲突就是把Git合并失败的⽂文件⼿手动编辑为我们希望的内容，再提交。<br>⽤用git log –graph命令可以看到分⽀支合并图。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git <span class="hljs-keyword">log</span> --graph --pretty=oneline --abbrev-commit<br></code></pre></td></tr></table></figure><h3 id="分⽀支管理理策略略"><a href="#分⽀支管理理策略略" class="headerlink" title="分⽀支管理理策略略"></a>分⽀支管理理策略略</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">合并分⽀支时，加上<span class="hljs-comment">--no-ff参数就可以⽤用普通模式合并，合并后的历史有分⽀支，能看出来曾经做过合并，⽽而直接不不使⽤用该参数fast</span><br>forward合并就看不不出来曾经做过合并<br></code></pre></td></tr></table></figure><p>–no-ff⽅方式的git merge<br>–no-ff参数，表示禁⽤用Fast forward<br>因为本次合并要创建⼀一个新的commit，所以加上-m参数，把commit描述写进去。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git <span class="hljs-keyword">merge</span> --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> dev<br></code></pre></td></tr></table></figure><h1 id="BUG-分⽀支"><a href="#BUG-分⽀支" class="headerlink" title="BUG 分⽀支"></a>BUG 分⽀支</h1><h2 id="dev-分⽀支上进⾏行行开发时，需要修复-bug"><a href="#dev-分⽀支上进⾏行行开发时，需要修复-bug" class="headerlink" title="dev 分⽀支上进⾏行行开发时，需要修复 bug"></a>dev 分⽀支上进⾏行行开发时，需要修复 bug</h2><p>1.git stash保存⼯工作现场<br>2.修复bug并提交</p><p><strong>3.git stash list</strong> 命令查看历史</p><p><strong>4. git stash apply vs git stash pop</strong><br>    git stash apply<br>       恢复后，stash内容并不不删除，需要git stash drop来删除<br>    git stash pop<br>       恢复同时把stash内容也删除了了</p><h1 id="多⼈人协作"><a href="#多⼈人协作" class="headerlink" title="多⼈人协作"></a>多⼈人协作</h1><h3 id="多⼈人协作的⼯工作模式通常是这样："><a href="#多⼈人协作的⼯工作模式通常是这样：" class="headerlink" title="多⼈人协作的⼯工作模式通常是这样："></a>多⼈人协作的⼯工作模式通常是这样：</h3><ol><li>⾸首先，可以试图⽤用git push origin <code>&lt;branch-name&gt;</code>推送⾃自⼰己的修改；</li><li>如果推送失败，则因为远程分⽀支⽐比你的本地更更新，需要先⽤用git pull试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再⽤用git push origin <code>&lt;branch-name&gt;</code>推送就能成功！</li></ol><p>本地分⽀支和远程分⽀支的链接关系没有创建，使⽤用</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git branch --set-upstream-<span class="hljs-keyword">to</span> &lt;branch-<span class="hljs-keyword">name</span>&gt; origin/&lt;branch-<span class="hljs-keyword">name</span>&gt;。<br></code></pre></td></tr></table></figure><p>创建远程origin的分⽀支到本地&amp;push，使⽤用</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git checkout -b dev origin/dev<br><span class="hljs-symbol">2 </span>git push origin dev<br></code></pre></td></tr></table></figure><h1 id="rebase-（变基）"><a href="#rebase-（变基）" class="headerlink" title="rebase （变基）"></a>rebase （变基）</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">rebase操作可以把本地未<span class="hljs-keyword">push</span>的分叉提交历史整理理成直线；<br>rebase的⽬目的是使得我们在查看历史提交的变化时更更容易易，因为分叉的提交需要三⽅方对⽐比。<br></code></pre></td></tr></table></figure><h1 id="TAG"><a href="#TAG" class="headerlink" title="TAG"></a>TAG</h1><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">发布⼀一个版本时，我们通常先在版本库中打⼀一个标签（<span class="hljs-keyword">tag</span>），这样，就唯⼀一确定了了打标签时刻的版本。将来⽆无论什什么时候，取某<br>个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的⼀一个快照。<br></code></pre></td></tr></table></figure><p>普通打标签（打在最新的⼀一次提交上）</p><p>1 git tag v1. 0<br>查看标签</p><p>1 git tag<br>给对应的commit打标签</p><p>1 git tag v0. 9 f52c<br>查看标签信息</p><p>1 git show <code>&lt;tagname&gt;</code><br>创建带有说明的标签，⽤用-a指定标签名，-m指定说明⽂文字：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>git tag -a v0. <span class="hljs-number">1</span> - m <span class="hljs-string">&quot;version 0.1 released&quot;</span> <span class="hljs-number">1094</span> adb<br></code></pre></td></tr></table></figure><p>删除标签</p><p>1 git tag -d v0. 1<br>推送某个标签到远程，使⽤用命令</p><p>1 git push origin <code>&lt;tagname&gt;</code><br>⼀一次性推送全部尚未推送到远程的本地标签</p><p>1 git push origin –tags<br>删除远程标签</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>从本地删除<br><span class="hljs-symbol">2 </span>git tag -d v0. <span class="hljs-number">9</span><br><span class="hljs-symbol">3 </span>从远程删除。删除命令也是push，但是格式如下<br><span class="hljs-symbol">4 </span>git push origin :refs/tags/v0. <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>基础巩固</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组方法整理</title>
    <link href="/2020/09/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/js/Array%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <url>/2020/09/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/js/Array%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是数组"><a href="#什么是数组" class="headerlink" title="什么是数组"></a>什么是数组</h3><ul><li>是值的有序集合</li><li>每一个值叫做一个元素</li><li>每一个元素在数组中的位置（数字表示）称为索引</li><li>每个jvascript数组都有一个length属性</li><li>数组是对象的特殊形式，数组索引和整数的属性名差不多，数组实现是经过优化的，用数字索引来访问数组元素比常规的对象属性快很多</li></ul><h3 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h3><ul><li>字面量创建 let arr=[1,3,3,4,,]</li><li>构造函数Array( )创建 let a=new Array(10)<blockquote><p>创建指定长度的数组，预分配数组空间;没有存储值，索引属性还未定义</p></blockquote></li><li>构造函数显式指定  let   a =new Array(3,2,4,2,8)</li></ul><blockquote><p>Array作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p></blockquote><h3 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ol><li><p>包含从0开始的不连续索引的数组</p></li><li><p>数组的length大于元素的个数</p><h4 id="稀疏数组的创建"><a href="#稀疏数组的创建" class="headerlink" title="稀疏数组的创建"></a>稀疏数组的创建</h4></li><li><p>Array（）构造函数创建  new Array(4)</p></li><li><p>简单的指定数组索引值大于当前数组长度来创建 a[10000]=9275389</p></li></ol><blockquote><p>有undefined的并不代表就是稀疏数组</p></blockquote><h3 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h3><h4 id="添加数组元素"><a href="#添加数组元素" class="headerlink" title="添加数组元素"></a>添加数组元素</h4><ul><li><p>末尾增加一个和多个元素</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.push</span>(<span class="hljs-string">&#x27;one&#x27;</span>,<span class="hljs-string">&#x27;two&#x27;</span>)<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[length]</span>=<span class="hljs-string">&#x27;three&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>首部在数组首部插入一个元素，并且将其他元素依次移到更高的索引–unshift()</p><h4 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h4></li><li><p>尾部删除pop（）</p><ul><li>使用一次数组数组尾部减少长度1,返回被删除元素的值</li></ul></li><li><p>首部删除shift（）</p><ul><li>从数组头部删除一个元素,将所哟偶元素下移到比当前索引低1的地方</li></ul></li><li><p>通用的插入，删除或替换元素的方法</p><ul><li>splice（）<blockquote><p>根据需要修改Length属性并移动元素到更高或更低的索引处去</p></blockquote></li><li>delete删除<blockquote><p>delete a[1]<br>不会改变数组length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白,变为稀疏数组</p></blockquote></li></ul></li></ul><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><p>返回一个布尔值，表示参数是否为数组，可以弥补typeof运算符的不足</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce(),reduceRight()"></a>reduce(),reduceRight()</h4><p>reduce是从左到右处理（从第一个成员到最后一个成员）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-keyword">function</span> (a, b) &#123;<br>  console.log(a, b);<br>  return a + b;<br>&#125;)<br><span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">10</span> <span class="hljs-number">5</span><br><span class="hljs-regexp">//</span>最后结果：<span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ol><li>累积变量，默认为数组的第一个成员</li><li>当前变量，默认为数组的第二个成员</li><li>当前位置（从0开始）</li><li>原数组<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 如果要对累积变量指定初值，可以把它放在reduce方法和reduceRight方法的第二个参数。</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(a, b)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;, <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><h5 id="reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。"><a href="#reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。" class="headerlink" title="reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。"></a>reduceRight则是从右到左（从最后一个成员到第一个成员），其他完全一样。</h5><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">function</span> <span class="hljs-selector-tag">subtract</span>(prev, cur) &#123;<br>  <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">prev</span> <span class="hljs-selector-tag">-</span> <span class="hljs-selector-tag">cur</span>;<br>&#125;<br><br><span class="hljs-selector-attr">[3, 2, 1]</span><span class="hljs-selector-class">.reduce</span>(subtract) <span class="hljs-comment">// 0</span><br><span class="hljs-selector-attr">[3, 2, 1]</span><span class="hljs-selector-class">.reduceRight</span>(subtract) <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><blockquote><p>reduce方法相当于3减去2再减去1，reduceRight方法相当于1减去2再减去3。</p></blockquote></li></ol><h5 id="reduce的宝藏用法"><a href="#reduce的宝藏用法" class="headerlink" title="reduce的宝藏用法"></a>reduce的宝藏用法</h5><ul><li>求最大值<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> max = a.reduce(<span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>&#123;<span class="hljs-keyword">return</span> x&gt;y?x:y&#125;)<br></code></pre></td></tr></table></figure></li><li>数组求积<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> product=a.reduce(<span class="hljs-function">(<span class="hljs-params">x,y</span>)=&gt;</span>&#123;<span class="hljs-keyword">return</span> x*y&#125;,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></li><li>数组求和<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> a=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-attribute">var</span> sum=a.reduce((x,y)=&gt;&#123;return x+y&#125;,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li>并集<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> obj=<span class="hljs-selector-attr">[&#123;x:1&#125;,&#123;y:2&#125;]</span><br><span class="hljs-selector-tag">var</span> merged=<span class="hljs-selector-tag">object</span><span class="hljs-selector-class">.reduce</span>(union)​<span class="hljs-comment">//=&gt;&#123;x:1,y:2&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">arr.splice(start, <span class="hljs-built_in">count</span>, <span class="hljs-keyword">addElement1, </span><span class="hljs-keyword">addElement2, </span>...);<br></code></pre></td></tr></table></figure><p>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p><h5 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;f&quot;</span>]<br>a <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]<br></code></pre></td></tr></table></figure><h5 id="起始位置如果是负数，就表示从倒数位置开始删除"><a href="#起始位置如果是负数，就表示从倒数位置开始删除" class="headerlink" title="起始位置如果是负数，就表示从倒数位置开始删除"></a>起始位置如果是负数，就表示从倒数位置开始删除</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]<br></code></pre></td></tr></table></figure><h5 id="单纯地插入元素，splice方法的第二个参数可以设为0。"><a href="#单纯地插入元素，splice方法的第二个参数可以设为0。" class="headerlink" title="单纯地插入元素，splice方法的第二个参数可以设为0。"></a>单纯地插入元素，splice方法的第二个参数可以设为0。</h5><h5 id="如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。"><a href="#如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。" class="headerlink" title="如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。"></a>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</h5><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>sort方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]</span><span class="hljs-selector-class">.sort</span>()<br><span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><br><span class="hljs-selector-attr">[4, 3, 2, 1]</span><span class="hljs-selector-class">.sort</span>()<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br><br><span class="hljs-selector-attr">[11, 101]</span><span class="hljs-selector-class">.sort</span>()<br><span class="hljs-comment">// [101, 11]</span><br><br><span class="hljs-selector-attr">[10111, 1101, 111]</span><span class="hljs-selector-class">.sort</span>()<br><span class="hljs-comment">// [10111, 1101, 111]</span><br></code></pre></td></tr></table></figure><h5 id="自定义方式排序"><a href="#自定义方式排序" class="headerlink" title="自定义方式排序"></a>自定义方式排序</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">10111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">111</span>].sort(<span class="hljs-keyword">function</span> (a, b) &#123;<br>  return a - b;<br>&#125;)<br><span class="hljs-regexp">//</span> [<span class="hljs-number">111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">10111</span>]<br>[<br>  &#123; name: <span class="hljs-string">&quot;张三&quot;</span>, age: <span class="hljs-number">30</span> &#125;,<br>  &#123; name: <span class="hljs-string">&quot;李四&quot;</span>, age: <span class="hljs-number">24</span> &#125;,<br>  &#123; name: <span class="hljs-string">&quot;王五&quot;</span>, age: <span class="hljs-number">28</span>  &#125;<br>].sort(<span class="hljs-keyword">function</span> (o1, o2) &#123;<br>  return o1.age - o2.age;<br>&#125;)<br><span class="hljs-regexp">//</span> [<br><span class="hljs-regexp">//</span>   &#123; name: <span class="hljs-string">&quot;李四&quot;</span>, age: <span class="hljs-number">24</span> &#125;,<br><span class="hljs-regexp">//</span>   &#123; name: <span class="hljs-string">&quot;王五&quot;</span>, age: <span class="hljs-number">28</span>  &#125;,<br><span class="hljs-regexp">//</span>   &#123; name: <span class="hljs-string">&quot;张三&quot;</span>, age: <span class="hljs-number">30</span> &#125;<br><span class="hljs-regexp">//</span> ]<br></code></pre></td></tr></table></figure><h5 id="从小到大"><a href="#从小到大" class="headerlink" title="从小到大"></a>从小到大</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">[<br>  &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;张三&quot;</span>, age: <span class="hljs-number">30</span> &#125;,<br>  &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;李四&quot;</span>, age: <span class="hljs-number">24</span> &#125;,<br>  &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;王五&quot;</span>, age: <span class="hljs-number">28</span>  &#125;<br>]<span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span> (o1, o2) &#123;<br>  <span class="hljs-keyword">return</span> o2.age - o1.age;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="从大到小"><a href="#从大到小" class="headerlink" title="从大到小"></a>从大到小</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xquery">[<br>  &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;张三&quot;</span>, age: <span class="hljs-number">30</span> &#125;,<br>  &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;李四&quot;</span>, age: <span class="hljs-number">24</span> &#125;,<br>  &#123;<span class="hljs-built_in"> name</span>: <span class="hljs-string">&quot;王五&quot;</span>, age: <span class="hljs-number">28</span>  &#125;<br>]<span class="hljs-built_in">.sort</span>(<span class="hljs-keyword">function</span> (o1, o2) &#123;<br>  <span class="hljs-keyword">return</span> o2.age - o1.age;<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="乱序"><a href="#乱序" class="headerlink" title="乱序"></a>乱序</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,],<br><br>　　r = arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>　　<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">.5</span> ? -<span class="hljs-number">1</span>:<span class="hljs-number">1</span>;<br><br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="valueOf-toString"><a href="#valueOf-toString" class="headerlink" title="valueOf(),toString()"></a>valueOf(),toString()</h4><ul><li>所有对象都拥有的方法,数组的valueOf方法返回数组本身</li><li>toString方法返回数组的字符串形式<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">var arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.toString() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;1,2,3&quot;</span><br><br>var arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br>arr.toString() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;1,2,3,4,5,6&quot;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h4><ul><li>push方法用于在数组的末端添加一个或多个元素，返回添加新元素后的数组长度，该方法会改变原数组</li><li>pop方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组。</li></ul><h4 id="unshift-，shift"><a href="#unshift-，shift" class="headerlink" title="unshift() ，shift()"></a>unshift() ，shift()</h4><ul><li>unshift()方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组。</li><li>shift()方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组。</li></ul><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>a.join(<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;1 2 3 4&#x27;</span><br>a.join(<span class="hljs-string">&#x27; | &#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;1 | 2 | 3 | 4&quot;</span><br>a.join() <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;1,2,3,4&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>如果数组成员是undefined或null或空位，会被转成空字符串。</p></li><li><p>巧用call方法：以指定参数作为分隔符，将所有数组成员连接为一个字符串返回，可以用于字符串或类似数组的对象。</p></li></ul><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Array</span>.prototype.<span class="hljs-keyword">join</span>.call(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &quot;h-e-l-l-o&quot;</span><br><br><span class="hljs-built_in">var</span> obj = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, length: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">Array</span>.prototype.<span class="hljs-keyword">join</span>.call(obj, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a-b&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><ul><li>concat方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</li><li>除了数组作为参数，concat也接受其他类型的值作为参数，添加到目标数组尾部。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[1, 2, 3]</span><span class="hljs-selector-class">.concat</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><ul><li>用于颠倒排列数组元素，返回改变后的数组。</li><li>注意，该方法将改变原数组。</li></ul><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><ul><li>用于提取目标数组的一部分，返回一个新数组，原数组不变。<br>arr.slice(start, end);</li><li>它的第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。</li><li>如果slice方法的参数是负数，则表示倒数计算的位置</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.slice(-<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]<br>a.slice(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;b&quot;</span>]<br><span class="hljs-regexp">//</span> -<span class="hljs-number">2</span>表示倒数计算的第二个位置，-<span class="hljs-number">1</span>表示倒数计算的第一个位置。<br></code></pre></td></tr></table></figure><ul><li>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组</li></ul><h5 id="重要应用-将类似数组的对象转为真正的数组。"><a href="#重要应用-将类似数组的对象转为真正的数组。" class="headerlink" title="重要应用:将类似数组的对象转为真正的数组。"></a>重要应用:将类似数组的对象转为真正的数组。</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Array</span>.prototype.<span class="hljs-keyword">slice</span>.<span class="hljs-keyword">call</span>(&#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, length: <span class="hljs-number">2</span> &#125;)<br>// [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br><br><span class="hljs-keyword">Array</span>.prototype.<span class="hljs-keyword">slice</span>.<span class="hljs-keyword">call</span>(document.querySelectorAll(&quot;div&quot;));<br><span class="hljs-keyword">Array</span>.prototype.<span class="hljs-keyword">slice</span>.<span class="hljs-keyword">call</span>(arguments);<br></code></pre></td></tr></table></figure><blockquote><p>上面代码的参数都不是数组，但是通过call方法，在它们上面调用slice方法，就可以把它们转为真正的数组</p></blockquote><h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><ul><li>将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回</li><li>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, index, arr)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> elem * index;<br>&#125;);<br><span class="hljs-comment">// [0, 2, 6]</span><br></code></pre></td></tr></table></figure></li><li>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量</li><li>如果数组有空位，map方法的回调函数在这个位置不会执行，会跳过数组的空位<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(n)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br>[<span class="hljs-number">1</span>, , <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, , &quot;a&quot;]</span><br></code></pre></td></tr></table></figure></li><li>map方法不会跳过undefined和null，但是会跳过空位</li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>forEach方法不返回值，只用来操作数据</p><p>如果数组遍历的目的是为了得到返回值，那么使用map方法，否则使用forEach方法。</p><ul><li>forEach的用法与map方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组</li><li>forEach方法也可以接受第二个参数，绑定参数函数的this变量</li><li>forEach方法也会跳过数组的空位。</li><li>不会跳过undefined和null，但是会跳过空位</li></ul><h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><ul><li>用于过滤数组成员，满足条件的成员组成一个新数组返回<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(elem) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">(elem</span> &gt; <span class="hljs-number">3</span>);<br>&#125;)<br>// [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></li><li>filter方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(elem, index, arr) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">index</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>&#125;);<br>// [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure></li><li>还可以接受第二个参数，用来绑定参数函数内部的this变量</li></ul><h4 id="some-every"><a href="#some-every" class="headerlink" title="some(),every()"></a>some(),every()</h4><ul><li>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。</li><li>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。</li></ul><h4 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(),lastIndexOf()"></a>indexOf(),lastIndexOf()</h4><p>这两个方法不能用来搜索NaN的位置，即它们无法确定数组成员是否包含NaN。</p><p>这是因为这两个方法内部，使用严格相等运算符（===）进行比较，而NaN是唯一一个不等于自身的值。</p><ul><li>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.indexOf(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>a.indexOf(<span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><ul><li>indexOf方法还可以接受第二个参数，表示搜索的开始位置。<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]</span><span class="hljs-selector-class">.indexOf</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure></li><li>lastIndexOf方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">var a = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>];<br>a.lastIndexOf(<span class="hljs-number">2</span>) <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br>a.lastIndexOf(<span class="hljs-number">7</span>) <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h4>数组方法之中，有不少返回的还是数组，所以可以链式使用<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ada">var users = [<br>  &#123;name: <span class="hljs-symbol">&#x27;tom</span>&#x27;, email: <span class="hljs-symbol">&#x27;tom</span>@example.com&#x27;&#125;,<br>  &#123;name: <span class="hljs-symbol">&#x27;peter</span>&#x27;, email: <span class="hljs-symbol">&#x27;peter</span>@example.com&#x27;&#125;<br>];<br><br>users<br>.map(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(user) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">user.email</span>;<br>&#125;)<br>.filter(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(email) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">/^t/.test(email)</span>;<br>&#125;)<br>.forEach(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(email) &#123;<br>  console.log(email);<br>&#125;);<br>// <span class="hljs-string">&quot;tom@example.com&quot;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Array</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-class与style绑定</title>
    <link href="/2020/06/14/vue/style&amp;class/"/>
    <url>/2020/06/14/vue/style&amp;class/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-class与style绑定"><a href="#vue-class与style绑定" class="headerlink" title="vue-class与style绑定"></a>vue-class与style绑定</h2><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><h4 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h4><ul><li>普通写法<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li>多字段控制<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span><br>  <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;static&quot;</span><br>  v-bind:<span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span><br>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li>绑定的数据对象不必内联定义在模板里<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//js-data</span><br><span class="hljs-keyword">data</span>: &#123;<br>  classObject: &#123;<br>    active: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">//js-计算属性</span><br>computed: &#123;<br>  classObject: function () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      active: <span class="hljs-keyword">this</span>.isActive &amp;&amp; !<span class="hljs-keyword">this</span>.error,<br>      <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-keyword">this</span>.error &amp;&amp; <span class="hljs-keyword">this</span>.error.type === <span class="hljs-string">&#x27;fatal&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br>&lt;!-- html --&gt;<br>&lt;div v-bind:<span class="hljs-class"><span class="hljs-keyword">class</span>=&quot;<span class="hljs-title">classObject</span>&quot;&gt;&lt;<span class="hljs-type">/div</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h4><ul><li>普通用法<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">//js</span><br><span class="xml">data: </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  activeClass: &#x27;active&#x27;,</span><br><span class="hljs-template-variable">  errorClass: &#x27;text-danger&#x27;</span><br><span class="hljs-template-variable">&#125;</span><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!-- html --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><strong><code>三元表达式</code></strong><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">&lt;div v-bind:<span class="hljs-keyword">class</span>=&quot;[<span class="hljs-symbol">isActive</span> ? <span class="hljs-symbol">activeClass</span> : &#x27;&#x27;, <span class="hljs-symbol">errorClass</span>]&quot;&gt;&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure></li><li><strong><code>在数组语法中也可以使用对象语法</code></strong><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;<span class="hljs-keyword">div</span> v-bind:<span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="用在组件上"><a href="#用在组件上" class="headerlink" title="用在组件上"></a>用在组件上</h4><ul><li>当在一个自定义组件上使用 class property 时，这些 class 将被添加到该组件的根元素上面</li><li>这个元素上已经存在的 class 不会被覆盖。</li></ul><h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><h4 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h4><ul><li>普通用法<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="xml">data: </span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  activeColor: &#x27;red&#x27;,</span><br><span class="hljs-template-variable">  fontSize: 30</span><br><span class="hljs-template-variable">&#125;</span><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;</span></span></span><span class="hljs-template-variable">&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>直接绑定到一个样式对象通常更好,模版更清晰<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta">data: &#123;<br>  styleObject: &#123;<br>    color: <span class="hljs-string">&#x27;red&#x27;</span>,<br>    fontSize: <span class="hljs-string">&#x27;13px&#x27;</span><br>  &#125;<br>&#125;<br>&lt;<span class="hljs-keyword">div</span> v-bind:style=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h4><ul><li>v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nim">&lt;<span class="hljs-keyword">div</span> v-<span class="hljs-keyword">bind</span>:style=<span class="hljs-string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;div <span class="hljs-symbol">:style=<span class="hljs-string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;&lt;/div&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-状态管理机制（eventBus vs VUEX）</title>
    <link href="/2020/06/14/vue/vuex/"/>
    <url>/2020/06/14/vue/vuex/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最初了解到eventBus和vuex并不清楚其原理，只知道无脑用，最近比较好奇这两者的区别，特以此文梳理</p></blockquote><h3 id="eventBus"><a href="#eventBus" class="headerlink" title="eventBus"></a>eventBus</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>又称事件总线，作为组件共同的事件中心</li><li>组件都可以上下平行的通知其他组件</li></ul><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>发布订阅模式</li><li>创建一个vue实例，通过一个空的vue实例作为桥梁实现vue组件间的通信</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不太方便，若不慎使用会造成难以维护的灾难，所以才需要更完善的vuex作为状态管理中心，将通知的概念上升到共享状态层次</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li>初始化<ul><li>方法一<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// event-bus.js</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> EventBus = <span class="hljs-keyword">new</span> Vue()<br></code></pre></td></tr></table></figure></li><li>方法二<blockquote><p>创建一个全局事件总线</p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// main.js</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Vue</span>.</span></span>prototype.$EventBus = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Vue()</span><br></code></pre></td></tr></table></figure></li></ul></li><li>可以维护一份公用数据或方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue(&#123;<br>    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">searchShow</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">showBtn</span>: <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-function"><span class="hljs-title">searchShowChange</span>(<span class="hljs-params">value</span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;boolean&#x27;</span>) &#123;<br>                <span class="hljs-built_in">this</span>.searchShow = <span class="hljs-literal">false</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.searchShow = !<span class="hljs-built_in">this</span>.searchShow<br>            &#125;<br>            <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;searchShowChange&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><ul><li><code>$on</code>/<code>$emit</code>/<code>$off</code><ul><li>$emit发送事件</li><li>$on接收事件</li><li><code>$off移除监听者</code><ul><li>十分重要，如果不手动清除，会一直存在，反复进入到接受组件内操作获取数据原本只有一次的操作将会有多次</li><li>移除单个事件EventBus.$off(‘aMsg’)</li><li>移除所有事件EventBus.$off()<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">before<span class="hljs-constructor">Destroy()</span> &#123;<br>   <span class="hljs-comment">//组件销毁前需要解绑事件。否则会出现重复触发事件的问题</span><br>   this.bus.<span class="hljs-constructor">$off(<span class="hljs-params">this</span>.$<span class="hljs-params">route</span>.<span class="hljs-params">path</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="VUEX"><a href="#VUEX" class="headerlink" title="VUEX"></a>VUEX</h3><h4 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h4><blockquote><p>当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏:<br>    1.多个视图依赖于同一状态。<br>    2.来自不同视图的行为需要变更同一状态。</p></blockquote><blockquote><p>对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p></blockquote><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>运用到了js设计模式中的单例模式，单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。</li><li>在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</li><li>通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性，我们的代码将会变得更结构化且易维护。</li></ul><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote><p>是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><ul><li><p>在计算属性中返回某个状态</p><blockquote><p>缺点：需要频繁地导入，并且在测试组件时需要模拟状态</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pf">computed: &#123;<br>    count () &#123;<br>      return store.<span class="hljs-keyword">state</span>.count<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 store 选项从根组件“注入”到每一个子组件中（需调用 Vue.use(Vuex)）</p><blockquote><p>子组件能通过 this.$store 访问到</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle">const app = <span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br>  store,<br>  components: &#123; Counter &#125;,<br>  template: `<br>    &lt;<span class="hljs-keyword">div</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;<br>      &lt;counter&gt;&lt;/counter&gt;<br>    &lt;/<span class="hljs-keyword">div</span>&gt;<br>  `<br>&#125;)<br><br>const Counter = &#123;<br>  template: `&lt;<span class="hljs-keyword">div</span>&gt;&#123;&#123; <span class="hljs-keyword">count</span> &#125;&#125;&lt;/<span class="hljs-keyword">div</span>&gt;`,<br>  computed: &#123;<br>    <span class="hljs-keyword">count</span> () &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$store.state.<span class="hljs-keyword">count</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>mapState 辅助函数</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 在单独构建的版本中辅助函数为 Vuex.mapState<br>import &#123; mapState &#125; <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br><br>export <span class="hljs-keyword">default</span> &#123;<br>  // ...<br>  computed: mapState(&#123;<br>    // 箭头函数可使代码更简练<br>    count: <span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count,<br><br>    // 传字符串参数 &#x27;count&#x27; 等同于 `<span class="hljs-keyword">state</span> =&gt; <span class="hljs-keyword">state</span>.count`<br>    countAlias: &#x27;count&#x27;,<br><br>    // 为了能够使用 `this` 获取局部状态，必须使用常规函数<br>    countPlusLocalState (<span class="hljs-keyword">state</span>) &#123;<br>      return <span class="hljs-keyword">state</span>.count + this.localCount<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>给 mapState 传一个字符串数组</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">computed: mapState([<br>  // 映射 this.count 为 store.<span class="hljs-keyword">state</span>.count<br>  &#x27;count&#x27;<br>])<br></code></pre></td></tr></table></figure></li><li><p>对象展开运算符与局部计算属性混合使用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">computed: &#123;<br>  localComputed () &#123; <span class="hljs-regexp">/* ... */</span> &#125;,<br>  <span class="hljs-regexp">//</span> 使用对象展开运算符将此对象混入到外部对象中<br>  ...mapState(&#123;<br>    <span class="hljs-regexp">//</span> ...<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><ul><li>使用情景<ul><li>从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数</li></ul></li><li>以属性的形式访问<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">store</span>.getters.doneTodos<br></code></pre></td></tr></table></figure></li><li>接收两个参数：state/getters<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">getters: &#123;<br>  // ...<br>  doneTodosCount: (<span class="hljs-keyword">state</span>, getters) =&gt; &#123;<br>    return getters.doneTodos.length<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>通过方法访问<blockquote><p>注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pf">getters: &#123;<br>  // ...<br>  getTodoById: (<span class="hljs-keyword">state</span>) =&gt; (id) =&gt; &#123;<br>    return <span class="hljs-keyword">state</span>.todos.find(todo =&gt; todo.id === id)<br>  &#125;<br>&#125;<br>store.getters.getTodoById(<span class="hljs-number">2</span>) // -&gt; &#123; id: <span class="hljs-number">2</span>, text: &#x27;...&#x27;, done: false &#125;<br></code></pre></td></tr></table></figure></li><li>mapGetters 辅助函数<blockquote><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">import &#123; mapGetters &#125; from <span class="hljs-string">&#x27;vuex&#x27;</span><br><br>export default &#123;<br>  <span class="hljs-regexp">//</span> ...<br>  computed: &#123;<br>  <span class="hljs-regexp">//</span> 使用对象展开运算符将 getter 混入 computed 对象中<br>    ...mapGetters([<br>      <span class="hljs-string">&#x27;doneTodosCount&#x27;</span>,<br>      <span class="hljs-string">&#x27;anotherGetter&#x27;</span>,<br>      <span class="hljs-regexp">//</span> ...<br>    ])<br>  &#125;<br>&#125;<br><br><span class="hljs-regexp">//</span>如果你想将一个 getter 属性另取一个名字，使用对象形式<br>...mapGetters(&#123;<br>  <span class="hljs-regexp">//</span> 把 `this.doneCount` 映射为 `this.<span class="hljs-variable">$store</span>.getters.doneTodosCount`<br>  doneCount: <span class="hljs-string">&#x27;doneTodosCount&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ul><h5 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h5><ul><li><p>向 store.commit 传入额外的参数，即 mutation 的 载荷（payload）</p><blockquote><p>在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读</p></blockquote><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pf">mutations: &#123;<br>  increment (<span class="hljs-keyword">state</span>, payload) &#123;<br>    <span class="hljs-keyword">state</span>.count += payload.amount<br>  &#125;<br>&#125;<br><br>store.commit(&#x27;increment&#x27;, &#123;<br>  amount: <span class="hljs-number">10</span><br>&#125;)<br><br>//对象风格的提交方式<br>store.commit(&#123;<br>  type: &#x27;increment&#x27;,<br>  amount: <span class="hljs-number">10</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>在组件中提交 Mutation</p><ul><li>this.$store.commit(‘xxx’)</li><li>使用 <code>mapMutations</code> 辅助函数将组件中的 methods 映射为 store.commit 调用  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">import &#123; mapMutations &#125; from <span class="hljs-string">&#x27;vuex&#x27;</span><br><br>export default &#123;<br>  <span class="hljs-regexp">//</span> ...<br>  methods: &#123;<br>    ...mapMutations([<br>      <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-regexp">//</span> 将 `this.increment()` 映射为 `this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)`<br><br>      <span class="hljs-regexp">//</span> `mapMutations` 也支持载荷：<br>      <span class="hljs-string">&#x27;incrementBy&#x27;</span> <span class="hljs-regexp">//</span> 将 `this.incrementBy(amount)` 映射为 `this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&#x27;incrementBy&#x27;</span>, amount)`<br>    ]),<br>    ...mapMutations(&#123;<br>      add: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-regexp">//</span> 将 `this.add()` 映射为 `this.<span class="hljs-variable">$store</span>.commit(<span class="hljs-string">&#x27;increment&#x27;</span>)`<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><code>注意事项</code></p><ul><li>最好提前在你的 store 中初始化好所有所需属性。</li><li>当需要在对象上添加新属性时，你应该使用 <code>Vue.set(obj, &#39;newProp&#39;, 123)</code>, 或者以新对象替换老对象。<blockquote><p>例如，利用对象展开运算符我们可以这样写:<br>  <code>state.obj = &#123; ...state.obj, newProp: 123 &#125;</code></p></blockquote></li></ul></li><li><p>使用常量替代 Mutation 事件类型</p><blockquote><p>1.常量更容易避免程序出现错误。如果把一个值赋给程序中的一个常量，而该常量已经有一个值，编译器就回报告错误。</p></blockquote></li></ul><p>2.在其多人协作的时候，方便统一管理，而且在其状态管理当中调用方法时一眼就是看出是其mutation里面的方法，有问题直接快速找到。<br> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pf"> // mutation-types.js<br>export <span class="hljs-keyword">const</span> SOME_MUTATION = &#x27;SOME_MUTATION&#x27;<br><br>// store.js<br>import Vuex <span class="hljs-keyword">from</span> &#x27;vuex&#x27;<br>import &#123; SOME_MUTATION &#125; <span class="hljs-keyword">from</span> &#x27;./mutation-types&#x27;<br><br><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>: &#123; ... &#125;,<br>  mutations: &#123;<br>    // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名<br>    [SOME_MUTATION] (<span class="hljs-keyword">state</span>) &#123;<br>      // mutate <span class="hljs-keyword">state</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></p><h5 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h5><ul><li><p>vs Mutations</p><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作</li></ul></li><li><p>基础使用</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">actions</span>: &#123;<br>  <span class="hljs-variable">increment</span> (&#123; <span class="hljs-variable">commit</span> &#125;) &#123;<br>    <span class="hljs-function"><span class="hljs-title">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分发 Action</p>  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">store<span class="hljs-selector-class">.dispatch</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br><span class="hljs-comment">// 以载荷形式分发</span><br>store<span class="hljs-selector-class">.dispatch</span>(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>, &#123;<br>  amount: <span class="hljs-number">10</span><br>&#125;)<br><br><span class="hljs-comment">// 以对象形式分发</span><br>store<span class="hljs-selector-class">.dispatch</span>(&#123;<br>  type: <span class="hljs-string">&#x27;incrementAsync&#x27;</span>,<br>  amount: <span class="hljs-number">10</span><br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>调用异步 API 和分发多重 mutation</p>  <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pf">actions: &#123;<br>  checkout (&#123; commit, <span class="hljs-keyword">state</span> &#125;, products) &#123;<br>    // 把当前购物车的物品备份起来<br>    <span class="hljs-keyword">const</span> savedCartItems = [...<span class="hljs-keyword">state</span>.cart.added]<br>    // 发出结账请求，然后乐观地清空购物车<br>    commit(types.CHECKOUT_REQUEST)<br>    // 购物 API 接受一个成功回调和一个失败回调<br>    shop.buyProducts(<br>      products,<br>      // 成功操作<br>      () =&gt; commit(types.CHECKOUT_SUCCESS),<br>      // 失败操作<br>      () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems)<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在组件中分发 Action</p><ul><li>与mutations类似,使用 this.$store.dispatch(‘xxx’) 分发 action</li><li>使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">  methods: &#123;<br>  ...mapActions([<br>    <span class="hljs-string">&#x27;increment&#x27;</span>, <span class="hljs-regexp">//</span> 将 `this.increment()` 映射为 this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;increment&#x27;</span>)<br><br>    <span class="hljs-regexp">//</span> mapActions 也支持载荷：<br>    <span class="hljs-string">&#x27;incrementBy&#x27;</span> <span class="hljs-regexp">//</span> 将 `this.incrementBy(amount)` 映射为 this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;incrementBy&#x27;</span>, amount)<br>  ]),<br>  ...mapActions(&#123;<br>    add: <span class="hljs-string">&#x27;increment&#x27;</span> <span class="hljs-regexp">//</span> 将 `this.add()` 映射为 this.<span class="hljs-variable">$store</span>.dispatch(<span class="hljs-string">&#x27;increment&#x27;</span>)<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>组合 Action</p></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//利用 async / await，我们可以如下组合 action</span><br><span class="hljs-comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span><br><br>actions: &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">actionA</span> (<span class="hljs-params">&#123; commit &#125;</span>)</span> &#123;<br>    commit(<span class="hljs-string">&#x27;gotData&#x27;</span>, <span class="hljs-keyword">await</span> getData())<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">actionB</span> (<span class="hljs-params">&#123; dispatch, commit &#125;</span>)</span> &#123;<br>    <span class="hljs-keyword">await</span> dispatch(<span class="hljs-string">&#x27;actionA&#x27;</span>) <span class="hljs-comment">// 等待 actionA 完成</span><br>    commit(<span class="hljs-string">&#x27;gotOtherData&#x27;</span>, <span class="hljs-keyword">await</span> getOtherData())<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vuex</tag>
      
      <tag>eventBus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue高阶组件相关知识点（包含$attrs/$listener/依赖注入）</title>
    <link href="/2020/06/14/vue/vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <url>/2020/06/14/vue/vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="vm-attrs"><a href="#vm-attrs" class="headerlink" title="vm.$attrs"></a>vm.$attrs</h3><h4 id="attrs的官方定义："><a href="#attrs的官方定义：" class="headerlink" title="$attrs的官方定义："></a>$attrs的官方定义：</h4><blockquote><p>包含了<code>父作用域</code>中<code>不作为prop</code>被识别 (且获取) 的 attribute 绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。</p></blockquote><p>了解了attrs的官方定义后我们可以提取两个比较重要的观点，即为：</p><h5 id="一、包含了父作用域中不作为prop被识别的attribute-属性"><a href="#一、包含了父作用域中不作为prop被识别的attribute-属性" class="headerlink" title="一、包含了父作用域中不作为prop被识别的attribute(属性)"></a>一、包含了<code>父作用域</code>中<code>不作为prop</code>被识别的attribute<code>(属性)</code></h5><ul><li>理解：传向一个组件，但是该组件<strong>没有相应prop定义</strong>的attribute<blockquote><p>显式定义的prop适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。所以组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上</p></blockquote><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!--父组件--&gt;</span></span><br><span class="xml"> <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!--这里 :child1和:child2是向后代组件传递数据--&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child1</span> <span class="hljs-attr">:child1</span>=<span class="hljs-string">&quot;child1&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">            <span class="hljs-attr">:child2</span>=<span class="hljs-string">&quot;child2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child1</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-comment">&lt;!--子组件 child1--&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-1&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!--注意这里的$attrs是父组件传入除被props接收外的参数--&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$attrs</span>[&#x27;child1&#x27;]&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li><li>如果父组件传入class，将会和子组件的class合并起来</li></ul><h5 id="二、在创建多级组件时非常有用"><a href="#二、在创建多级组件时非常有用" class="headerlink" title="二、在创建多级组件时非常有用"></a>二、在创建多级组件时非常有用</h5><blockquote><p>主要在<code>父组件</code>和<code>孙组件</code>之间通信时$attrs属性非常有用</p></blockquote><ul><li>如果不希望组件的根元素继承attribute可以设置inheritAttrs:false<ul><li>这样就可以手动的决定这些attrs会被赋予在哪个元素上</li><li>inheritAttrs:false不会影响style/class的绑定<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-comment">&lt;!-- 子组件 child1,将attrs赋予给孙元素 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-1&quot;</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$attrs</span>[&#x27;child1&#x27;]&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="xml">       <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span></span><br><span class="xml">        <span class="hljs-comment">&lt;!-- 孙组件中通过v-bind=&#x27;$attrs&#x27;接受数据 --&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child2</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="vm-listeners"><a href="#vm-listeners" class="headerlink" title="vm.$listeners"></a>vm.$listeners</h3><h4 id="listeners官方定义"><a href="#listeners官方定义" class="headerlink" title="$listeners官方定义"></a>$listeners官方定义</h4><blockquote><p>包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。</p></blockquote><p>.native修饰符扩展</p><blockquote><p>你可能有很多次想要在一个组件的根元素上直接监听一个原生事件。这时，你可以使用 v-on 的 .native 修饰符<br><base-input v-on:focus.native="onFocus"></base-input></p></blockquote><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul><li>中间组件（子组件）绑定 v-on=”$listeners” 将所有的事件监听器指向这个组件的某个特定的子元素</li><li>子/孙组件均可通过形如this.$listeners.test2()调用父组件的方法</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--父组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这里 :one和:two是向后代组件传递数据--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child1</span> <span class="hljs-attr">:child1</span>=<span class="hljs-string">&quot;child1&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">:child2</span>=<span class="hljs-string">&quot;child2&quot;</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">test1</span>=<span class="hljs-string">&quot;onTest1&quot;</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">test2</span>=<span class="hljs-string">&quot;onTest2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 子组件 child1 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 子组件中通过v-bind=&#x27;$attrs&#x27;接受数据，通过$listeners接收事件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">child2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child2</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><blockquote><p>使用场景：$parent无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code><br>provide 和 inject 主要在开发高阶插件/组件库时使用。并不推荐用于普通应用程序代码中。</p></blockquote><h4 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h4><ul><li>允许我们指定我们想要提供给后代组件的数据/方法<h4 id="inject"><a href="#inject" class="headerlink" title="inject"></a>inject</h4></li><li>任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的 property</li></ul><blockquote><p>提示：provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的 property 还是可响应的。</p></blockquote><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li><p>一般应用</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 父级组件提供 &#x27;foo&#x27;</span><br><span class="hljs-built_in">var</span> Provider = &#123;<br>  provide: &#123;<br>    foo: <span class="hljs-string">&#x27;bar&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 子组件注入 &#x27;foo&#x27;</span><br><span class="hljs-built_in">var</span> Child = &#123;<br>  inject: [<span class="hljs-string">&#x27;foo&#x27;</span>],<br>  created () &#123;<br>    console.log(<span class="hljs-keyword">this</span>.foo) <span class="hljs-comment">// =&gt; &quot;bar&quot;</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">//使用一个注入的值作为一个 property 的默认值</span><br><span class="hljs-keyword">const</span> Child = &#123;<br>  inject: [<span class="hljs-string">&#x27;foo&#x27;</span>],<br>  props: &#123;<br>    bar: &#123;<br>      <span class="hljs-literal">default</span> () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.foo<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 使用一个注入的值作为数据入口：</span><br><span class="hljs-keyword">const</span> Child = &#123;<br>  inject: [<span class="hljs-string">&#x27;foo&#x27;</span>],<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      bar: <span class="hljs-keyword">this</span>.foo<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 在 2.5.0+ 的注入可以通过设置默认值使其变成可选项：</span><br><span class="hljs-keyword">const</span> Child = &#123;<br>  inject: &#123;<br>    foo: &#123; <span class="hljs-literal">default</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//如果它需要从一个不同名字的 property 注入，则使用 from 来表示其源 property：</span><br><span class="hljs-keyword">const</span> Child = &#123;<br>  inject: &#123;<br>    foo: &#123;<br>      <span class="hljs-keyword">from</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>      <span class="hljs-literal">default</span>: <span class="hljs-string">&#x27;foo&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//与 prop 的默认值类似，你需要对非原始值使用一个工厂方法：</span><br><span class="hljs-keyword">const</span> Child = &#123;<br>  inject: &#123;<br>    foo: &#123;<br>      <span class="hljs-keyword">from</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>      <span class="hljs-literal">default</span>: () =&gt; [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用 ES2015 Symbols、函数 provide 和对象 inject</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> s = Symbol()<br><br><span class="hljs-keyword">const</span> Provider = &#123;<br>  provide () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      [<span class="hljs-meta">s</span>]: <span class="hljs-string">&#x27;foo&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> Child = &#123;<br>  inject: &#123; s &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js设计模式核心原理学习之创建型</title>
    <link href="/2020/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/"/>
    <url>/2020/06/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在 JavaScript 中，我们使用构造函数去初始化对象，就是应用了构造器模式。</p><h3 id="例子🌰"><a href="#例子🌰" class="headerlink" title="例子🌰"></a>例子🌰</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">User(<span class="hljs-params">name</span> , <span class="hljs-params">age</span>, <span class="hljs-params">career</span>)</span> &#123;<br>    this.name = name<br>    this.age = age<br>    this.career = career<br>&#125;<br>const user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">User(<span class="hljs-params">name</span>, <span class="hljs-params">age</span>, <span class="hljs-params">career</span>)</span><br></code></pre></td></tr></table></figure><h3 id="变与不变"><a href="#变与不变" class="headerlink" title="变与不变"></a>变与不变</h3><p>很明显，变的是每个user的姓名、年龄、工种这些值，这是用户的个性，不变的是每个员工都具备姓名、年龄、工种这些属性，这是用户的共性。</p><p>构造器将 name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变，同时将 name、age、career 各自的取值操作开放，确保了个性的灵活。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>本质上是去抽象了每个对象实例的变与不变</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>工厂模式其实就是将<strong>创建对象的过程</strong>单独封装。</li><li>本质上是去抽象不同构造函数（类）之间的变与不变。</li><li>工厂模式的目的，就是为了实现无脑传参，就是为了爽！<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">User</span>(<span class="hljs-params">name , age, career, work</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name<br>    <span class="hljs-built_in">this</span>.age = age<br>    <span class="hljs-built_in">this</span>.career = career<br>    <span class="hljs-built_in">this</span>.work = work<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Factory</span>(<span class="hljs-params">name, age, career</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> work<br>    <span class="hljs-keyword">switch</span>(career) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;coder&#x27;</span>:<br>            work =  [<span class="hljs-string">&#x27;写代码&#x27;</span>,<span class="hljs-string">&#x27;写系分&#x27;</span>, <span class="hljs-string">&#x27;修Bug&#x27;</span>]<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;product manager&#x27;</span>:<br>            work = [<span class="hljs-string">&#x27;订会议室&#x27;</span>, <span class="hljs-string">&#x27;写PRD&#x27;</span>, <span class="hljs-string">&#x27;催更&#x27;</span>]<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;boss&#x27;</span>:<br>            work = [<span class="hljs-string">&#x27;喝茶&#x27;</span>, <span class="hljs-string">&#x27;看报&#x27;</span>, <span class="hljs-string">&#x27;见客户&#x27;</span>]<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;xxx&#x27;</span>:<br>            <span class="hljs-comment">// 其它工种的职责分配</span><br>            ...<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(name, age, career, work)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>它很像我们去餐馆点菜：比如说点一份西红柿炒蛋，我们不用关心西红柿怎么切、怎么打鸡蛋这些菜品制作过程中的问题，我们只关心摆上桌那道菜。在工厂模式里，我传参这个过程就是点菜，工厂函数里面运转的逻辑就相当于炒菜的厨师和上桌的服务员做掉的那部分工作——这部分工作我们同样不用关心，我们只要能拿到工厂交付给我们的实例结果就行了。</p></blockquote><h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><h3 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h3><p>是围绕一个超级工厂创建其他工厂。</p><h3 id="与简单工厂的对比"><a href="#与简单工厂的对比" class="headerlink" title="与简单工厂的对比"></a>与简单工厂的对比</h3><ul><li>它们的共同点，在于都尝试去分离一个系统中变与不变的部分。</li><li>它们的不同在于场景的复杂度。</li><li>在简单工厂的使用场景里，处理的对象是类，并且是一些非常好对付的类——它们的共性容易抽离，同时因为逻辑本身比较简单，故而不苛求代码可扩展性。</li></ul><h3 id="抽象工厂本质"><a href="#抽象工厂本质" class="headerlink" title="抽象工厂本质"></a>抽象工厂本质</h3><p>处理的其实也是类，但是是一帮非常棘手、繁杂的类，这些类中不仅能划分出门派，还能划分出等级，同时存在着千变万化的扩展可能性——这使得我们必须对共性作更特别的处理、使用抽象类去降低扩展的成本，同时需要对类的性质作划分，于是有了这样的四个关键角色：</p><ul><li><strong>抽象工厂</strong>（抽象类，它不能被用于生成具体实例）： 用于声明最终目标产品的共性。在一个系统里，抽象工厂可以有多个（大家可以想象我们的手机厂后来被一个更大的厂收购了，这个厂里除了手机抽象类，还有平板、游戏机抽象类等等），每一个抽象工厂对应的这一类的产品，被称为“产品族”。</li><li><strong>具体工厂</strong>（用于生成产品族里的一个具体的产品）： 继承自抽象工厂、实现了抽象工厂里声明的那些方法，用于创建具体的产品的类。</li><li><strong>抽象产品</strong>（抽象类，它不能被用于生成具体实例）： 上面我们看到，具体工厂里实现的接口，会依赖一些类，这些类对应到各种各样的具体的细粒度产品（比如操作系统、硬件等），这些具体产品类的共性各自抽离，便对应到了各自的抽象产品类。</li><li><strong>具体产品</strong>（用于生成产品族里的一个具体的产品所依赖的更细粒度的产品）： 比如我们上文中具体的一种操作系统、或具体的一种硬件等。</li></ul><p>只需留意以下三点：</p><ul><li>学会用 ES6 模拟 JAVA 中的抽象类；</li><li>了解抽象工厂模式中四个角色的定位与作用；</li><li>对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点，这样的模式就叫做单例模式。</p><blockquote><p>例子：vuex-一个 Vue 实例只能对应一个 Store,但当组件非常多、组件间关系复杂、且嵌套层级很深的时候，这种原始的通信方式会使我们的逻辑变得复杂难以维护。这时最好的做法是将共享的数据抽出来、放在全局，供组件们按照一定的的规则去存取数据，保证状态以一种可预测的方式发生变化。于是便有了 Vuex，这个用来存放共享数据的唯一数据源，就是 Store。</p></blockquote><h3 id="静态方法实现"><a href="#静态方法实现" class="headerlink" title="静态方法实现"></a>静态方法实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> SingleDog &#123;<br>    show<span class="hljs-literal">()</span> &#123;<br>        console.log(&#x27;我是一个单例对象&#x27;)<br>    &#125;<br>    static get<span class="hljs-constructor">Instance()</span> &#123;<br>        <span class="hljs-comment">// 判断是否已经new过1个实例</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SingleDog</span>.</span></span>instance) &#123;<br>            <span class="hljs-comment">// 若这个唯一的实例不存在，那么先创建它</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SingleDog</span>.</span></span>instance = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SingleDog()</span><br>        &#125;<br>        <span class="hljs-comment">// 如果这个唯一的实例已经存在，则直接返回</span><br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SingleDog</span>.</span></span>instance<br>    &#125;<br>&#125;<br><br>const s1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SingleDog</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br>const s2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SingleDog</span>.</span></span>get<span class="hljs-constructor">Instance()</span><br><br><span class="hljs-comment">// true</span><br>s1<span class="hljs-operator"> === </span>s2<br></code></pre></td></tr></table></figure><h3 id="闭包实现"><a href="#闭包实现" class="headerlink" title="闭包实现"></a>闭包实现</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs smali">SingleDog.getInstance = (function() &#123;<br>    // 定义自由变量instance，模拟私有变量<br>    let<span class="hljs-built_in"> instance </span>= null<br>   <span class="hljs-built_in"> return </span>function() &#123;<br>        // 判断自由变量是否为null<br>        if(!instance) &#123;<br>            // 如果为null则new出唯一实例<br>           <span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>SingleDog()<br>        &#125;<br>       <span class="hljs-built_in"> return </span>instance<br>    &#125;<br>&#125;)()<br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>原型编程范式的核心思想就是利用实例来描述对象，用实例作为定义对象和继承的基础。在 JavaScript 中，原型编程范式的体现就是基于<strong>原型链的继承</strong>。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li>在 JavaScript 中，每个构造函数都拥有一个prototype属性，它指向构造函数的原型对象，这个原型对象中有一个 construtor 属性指回构造函数；</li><li>每个实例都有一个__proto__属性，当我们使用构造函数去创建实例时，实例的__proto__属性就会指向构造函数的原型对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈MVC、MVP、MVVM架构模式</title>
    <link href="/2020/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B5%85%E8%B0%88MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/06/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%B5%85%E8%B0%88MVC%E3%80%81MVP%E3%80%81MVVM%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考阮一峰网络日志，廖雪峰官方网站，以及部分网络资料总结</p></blockquote><h2 id="mvc-model-view-controller"><a href="#mvc-model-view-controller" class="headerlink" title="mvc(model-view-controller)"></a>mvc(model-view-controller)</h2><h3 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h3><p>MVC是三个单词的首字母缩写，它们是Model（模型）、View（视图）和Controller（控制）</p><ul><li>最上面的一层，是直接面向最终用户的”视图层”（View）。它是提供给用户的操作界面，是程序的外壳。</li><li>最底下的一层，是<strong>核心的”数据层”（Model）</strong>，也就是程序需要操作的数据或信息。</li><li>中间的一层，就是”控制层”（Controller），它负责根据用户从”视图层”输入的指令，选取”数据层”中的数据，然后对其进行相应的操作，产生最终结果。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/5/1714950836ab2b65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="简单理解"><a href="#简单理解" class="headerlink" title="简单理解"></a>简单理解</h3><p>用户操作-&gt;View（负责接收用户的输入操作）-&gt;Controller（业务逻辑处理）-&gt;Model（数据持久化）-&gt;View（将结果反馈给View）</p><h3 id="联系与作用"><a href="#联系与作用" class="headerlink" title="联系与作用"></a>联系与作用</h3><p>这三层是紧密联系在一起的，但又是互相独立的，每一层内部的变化不影响其他层。每一层都对外提供接口（Interface），供上面一层调用。这样一来，软件就可以实现模块化，修改外观或者变更数据都不用修改其他层，大大方便了维护和升级。</p><blockquote><p>JavaEE中的SSH框架（Struts/Spring/Hibernate），Struts（View, STL）-Spring（Controller, Ioc、Spring MVC）-Hibernate（Model, ORM）以及ASP.NET中的ASP.NET MVC框架，xxx.cshtml-xxxcontroller-xxxmodel。</p></blockquote><h2 id="mvp（model-view-presenter）"><a href="#mvp（model-view-presenter）" class="headerlink" title="mvp（model-view-presenter）"></a>mvp（model-view-presenter）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，<strong>由Presenter充当桥梁</strong>，做到View-Model之间通信的完全隔离。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/5/171495f433d4ed1f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><p>.NET程序员熟知的ASP.NET webform、winform基于事件驱动的开发技术就是使用的MVP模式。控件组成的页面充当View，实体数据库操作充当Model，而View和Model之间的控件数据绑定操作则属于Presenter。控件事件的处理可以通过自定义的IView接口实现，而View和IView都将对Presenter负责。</p></blockquote><h2 id="mvvm-model-view-viewModel"><a href="#mvvm-model-view-viewModel" class="headerlink" title="mvvm(model-view-viewModel)"></a>mvvm(model-view-viewModel)</h2><p>如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“<strong>数据模型数据双向绑定</strong>”的思想作为核心，因此在View和Model之间没有联系，<strong>通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的</strong>，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/5/17149616b6cb9aef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><blockquote><p>MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。</p></blockquote><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。</p><h3 id="MVVM的设计思想"><a href="#MVVM的设计思想" class="headerlink" title="MVVM的设计思想"></a>MVVM的设计思想</h3><p>关注Model的变化，让MVVM框架去自动更新DOM的状态，从而把开发者从操作DOM的繁琐步骤中解脱出来！</p><blockquote><p>这里以前端框架VUE举例说明MVVM，当然还有许多有名的框架都用的是MVVM模式；MVVM的好处就是数据驱动，数据变，则页面变，这样就能用简单的代码，实现比较复杂的逻辑操作；因此MVVM框架比较适合逻辑复杂的前端项目，比如一些管理系统等。</p></blockquote><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>从mvc一直发展到mvvm，使view/model能够完全分离，是一个解耦的过程，使每个部分都能更专注于自身的作用，代码逻辑更清晰，也使开发者的工作更轻松。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue2.X自定义组件v-model和.sync修饰符的深入理解</title>
    <link href="/2020/06/07/vue/sync/"/>
    <url>/2020/06/07/vue/sync/</url>
    
    <content type="html"><![CDATA[<h2 id="v-model在自定义组件中的应用"><a href="#v-model在自定义组件中的应用" class="headerlink" title="v-model在自定义组件中的应用"></a>v-model在自定义组件中的应用</h2><h3 id="v-model的作用"><a href="#v-model的作用" class="headerlink" title="v-model的作用"></a>v-model的作用</h3><ul><li>前提是props是单向数据流，我们不能直接在子组件去改变父组件传过来的props，v-model是可以方便我们来改变该值；</li><li>无需在父组件去监听函数去改变v-model改变的值；</li><li>父组件仍可以监听发送的事件；</li><li>比较适用于表单值修改比较频繁的时候；</li></ul><h3 id="v-model使用方法"><a href="#v-model使用方法" class="headerlink" title="v-model使用方法"></a>v-model使用方法</h3><ul><li>在子组件中定义model和props</li><li>通过发送在model下定义的事件名通知v-model绑定值的改变</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">mode</span><span class="hljs-variable">l:</span> &#123;<br>  prop: <span class="hljs-string">&#x27;value&#x27;</span>,<br>  even<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;change&#x27;</span>//自定义改变值的事件，之后我们可以通过发送该事件通知v-model绑定值的改变<br>&#125;,<br>prop<span class="hljs-variable">s:</span> &#123;<br>  /**<br>   * 价格设置值<br>   * @model<br>   */<br>  value: &#123;<br>    <span class="hljs-built_in">type</span>: Number,<br>    defaul<span class="hljs-variable">t:</span> <span class="hljs-number">0</span><br>  &#125;<br>&#125;,<br>method<span class="hljs-variable">s:</span>&#123;<br>  <span class="hljs-keyword">change</span> (value) &#123;<br>    //这样可以直接将父组件v-model绑定的值改变<br>    this.$emit(<span class="hljs-string">&#x27;change&#x27;</span>, value * <span class="hljs-number">1</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync修饰符的实际应用"><a href="#sync修饰符的实际应用" class="headerlink" title=".sync修饰符的实际应用"></a>.sync修饰符的实际应用</h2><h3 id="sync的作用"><a href="#sync的作用" class="headerlink" title=".sync的作用"></a>.sync的作用</h3><ul><li>通常我们需要通过事件机制，子组件发送一个事件，父组件监听修改值</li><li>.sync可以省去监听这一步</li></ul><h3 id="sync的用法"><a href="#sync的用法" class="headerlink" title=".sync的用法"></a>.sync的用法</h3><ul><li>在父组件传props的时候后面添加一个.sync修饰符</li><li>通过在子组件中发送”update:prop”事件直接更新prop</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>子组件<br>this.<span class="hljs-variable">$emit</span>(<span class="hljs-string">&#x27;update:prop&#x27;</span>, prop)<br><span class="hljs-regexp">//</span>父组件<br>&lt;div :prop.sync=<span class="hljs-string">&quot;prop&quot;</span> /&gt;<br><span class="hljs-regexp">//</span>可以实现prop的联动<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue基础知识概览(包含vue3.0)</title>
    <link href="/2020/06/07/vue/vue%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%A6%82%E8%A7%88/"/>
    <url>/2020/06/07/vue/vue%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%A6%82%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h3 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h3><h4 id="说说你对MVVM的理解"><a href="#说说你对MVVM的理解" class="headerlink" title="说说你对MVVM的理解"></a>说说你对MVVM的理解</h4><ul><li>Model-View-ViewModel的缩写，Model代表数据模型，View代表UI组件,ViewModel将Model和View关联起来</li><li>数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知<strong>viewModel</strong>层更新数据</li></ul><blockquote><p><a href="https://juejin.im/post/5e898a3be51d45470125665f">了解mvc/mvp/mvvm的区别</a></p></blockquote><h4 id="Vue2-x响应式数据-双向绑定原理"><a href="#Vue2-x响应式数据-双向绑定原理" class="headerlink" title="Vue2.x响应式数据/双向绑定原理"></a>Vue2.x响应式数据/双向绑定原理</h4><ul><li>Vue 数据双向绑定主要是指：<strong>数据变化更新视图，视图变化更新数据</strong>。其中，View变化更新Data，可以通过事件监听的方式来实现，所以 Vue数据双向绑定的工作主要是如何<strong>根据Data变化更新View</strong>。</li><li><strong>简述</strong>：<ul><li>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 全部转为 getter/setter。</li><li>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</li><li>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</li></ul></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/5/21/172362b61334efbc?w=1200&h=750&f=png&s=65135"></p><ul><li>深入理解：<ul><li><strong>监听器 Observer</strong>：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。</li><li><strong>解析器 Compile</strong>：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。</li><li><strong>订阅者 Watcher</strong>：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新——这是一个典型的观察者模式</li><li><strong>订阅器 Dep</strong>：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。</li></ul></li></ul><h4 id="你知道Vue3-x响应式数据原理吗？"><a href="#你知道Vue3-x响应式数据原理吗？" class="headerlink" title="你知道Vue3.x响应式数据原理吗？"></a>你知道Vue3.x响应式数据原理吗？</h4><ul><li><strong>Vue3.x改用Proxy替代Object.defineProperty</strong>。</li><li>因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。</li><li>Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？<ul><li>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</li><li>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</li></ul></li></ul><h4 id="Proxy-与-Object-defineProperty-优劣对比"><a href="#Proxy-与-Object-defineProperty-优劣对比" class="headerlink" title="Proxy 与 Object.defineProperty 优劣对比"></a>Proxy 与 Object.defineProperty 优劣对比</h4><ul><li>Proxy 的优势如下:<ul><li>Proxy 可以直接监听对象而非属性；</li></ul></li><li>Proxy 可以直接监听数组的变化；<ul><li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li><li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li><li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ul></li><li>Object.defineProperty 的优势如下:<ul><li>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</li></ul></li></ul><h3 id="VUEX篇"><a href="#VUEX篇" class="headerlink" title="VUEX篇"></a>VUEX篇</h3><h4 id="Vuex-是什么？"><a href="#Vuex-是什么？" class="headerlink" title="Vuex 是什么？"></a>Vuex 是什么？</h4><blockquote><p>运用到了js设计模式中的单例模式，单例模式想要做到的是，不管我们尝试去创建多少次，它都只给你返回第一次所创建的那唯一的一个实例。</p></blockquote><ul><li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。<ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li></ul></li></ul><blockquote><p>Vuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 ——Vuex官方文档</p></blockquote><ul><li>主要包括以下几个模块：<ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul></li></ul><h4 id="什么情况下使用-Vuex？"><a href="#什么情况下使用-Vuex？" class="headerlink" title="什么情况下使用 Vuex？"></a>什么情况下使用 Vuex？</h4><ul><li>如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可</li><li>需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态</li></ul><h4 id="Vuex和单纯的全局对象有什么区别？"><a href="#Vuex和单纯的全局对象有什么区别？" class="headerlink" title="Vuex和单纯的全局对象有什么区别？"></a>Vuex和单纯的全局对象有什么区别？</h4><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li></ul><h4 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h4><ul><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li><li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ul><h4 id="新增：vuex的action有返回值吗？返回的是什么？"><a href="#新增：vuex的action有返回值吗？返回的是什么？" class="headerlink" title="新增：vuex的action有返回值吗？返回的是什么？"></a>新增：vuex的action有返回值吗？返回的是什么？</h4><ul><li>store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise</li><li>Action 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程，可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程<blockquote><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote></li></ul><h4 id="新增：为什么不直接分发mutation-而要通过分发action之后提交-mutation变更状态"><a href="#新增：为什么不直接分发mutation-而要通过分发action之后提交-mutation变更状态" class="headerlink" title="新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态"></a>新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态</h4><ul><li>mutation 必须同步执行，我们可以在 action 内部执行异步操作</li><li>可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更）</li></ul><h3 id="常规篇"><a href="#常规篇" class="headerlink" title="常规篇"></a>常规篇</h3><h4 id="computed-和-watch-的区别和运用的场景？"><a href="#computed-和-watch-的区别和运用的场景？" class="headerlink" title="computed 和 watch 的区别和运用的场景？"></a>computed 和 watch 的区别和运用的场景？</h4><ul><li>computed：是计算属性，依赖其它属性值，并且 computed 的值有<strong>缓存</strong>，只有它<strong>依赖的属性值</strong>发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</li><li>watch：没有缓存性，更多的是「<strong>观察</strong>」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；当我们需要深度监听对象中的属性时，可以打开deep：true选项，这样便会对对象中的每一项进行监听</li><li><strong>运用场景</strong>：<ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用watch选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul></li></ul><h4 id="Vue2-x组件通信有哪些方式？"><a href="#Vue2-x组件通信有哪些方式？" class="headerlink" title="Vue2.x组件通信有哪些方式？"></a>Vue2.x组件通信有哪些方式？</h4><ul><li>父子组件通信<ul><li>事件机制(**父-&gt;子props,子-&gt;父 <code>$on、$emit</code>)</li><li>获取父子组件实例 <code>$parent、$children</code></li><li>Ref 获取实例的方式调用组件的属性或者方法</li><li>Provide、inject (不推荐使用，组件库时很常用)</li></ul></li><li>兄弟组件通信<ul><li><strong>eventBus</strong> 这种方法通过<strong>一个空的 Vue实例作为中央事件总线（事件中心</strong>），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件<blockquote><p>Vue.prototype.<code>$bus</code> = new Vue</p></blockquote></li><li><strong>Vuex</strong></li></ul></li><li>跨级组件通信<ul><li>Vuex</li><li><code>$attrs、$listeners</code></li><li>Provide、inject</li></ul></li></ul><h4 id="说一下v-if和v-show的区别"><a href="#说一下v-if和v-show的区别" class="headerlink" title="说一下v-if和v-show的区别"></a>说一下v-if和v-show的区别</h4><ul><li>当条件不成立时，v-if不会渲染DOM元素，v-show操作的是样式(display)，切换当前DOM的显示和隐藏。</li><li>v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；</li><li>v-show 则适用于需要非常频繁切换条件的场景。</li></ul><h4 id="为什么-v-for-和-v-if-不建议用在一起"><a href="#为什么-v-for-和-v-if-不建议用在一起" class="headerlink" title="为什么 v-for 和 v-if 不建议用在一起"></a>为什么 v-for 和 v-if 不建议用在一起</h4><ul><li>当 v-for 和 v-if 处于同一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。如果要遍历的数组很大，而真正要展示的数据很少时，这将造成很大的性能浪费</li><li>这种场景建议使用 computed，先对数据进行过滤</li></ul><h4 id="组件中的data为什么是一个函数？"><a href="#组件中的data为什么是一个函数？" class="headerlink" title="组件中的data为什么是一个函数？"></a>组件中的data为什么是一个函数？</h4><ul><li>一个组件被复用多次的话，也就会创建多个实例。本质上，这些实例用的都是同一个构造函数。</li><li>如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。</li></ul><h4 id="子组件为什么不可以修改父组件传递的Prop？-怎么理解vue的单向数据流？"><a href="#子组件为什么不可以修改父组件传递的Prop？-怎么理解vue的单向数据流？" class="headerlink" title="子组件为什么不可以修改父组件传递的Prop？/怎么理解vue的单向数据流？"></a>子组件为什么不可以修改父组件传递的Prop？/怎么理解vue的单向数据流？</h4><ul><li>Vue提倡单向数据流,即父级props的更新会流向子组件,但是反过来则不行。</li><li>这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解。</li><li>如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</li></ul><h4 id="v-model是如何实现双向绑定的？"><a href="#v-model是如何实现双向绑定的？" class="headerlink" title="v-model是如何实现双向绑定的？"></a>v-model是如何实现双向绑定的？</h4><ul><li>v-model是用来在表单控件或者组件上创建双向绑定的</li><li>他的本质是v-bind和v-on的语法糖</li><li>在一个组件上使用v-model，默认会为组件绑定名为value的prop和名为input的事件</li></ul><h4 id="nextTick的实现原理是什么？"><a href="#nextTick的实现原理是什么？" class="headerlink" title="nextTick的实现原理是什么？"></a>nextTick的实现原理是什么？</h4><ul><li>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。</li><li>nextTick主要使用了<strong>宏任务</strong>和<strong>微任务</strong>。</li><li>根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</li></ul><h4 id="Vue不能检测数组的哪些变动？Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？"><a href="#Vue不能检测数组的哪些变动？Vue-怎么用-vm-set-解决对象新增属性不能响应的问题-？" class="headerlink" title="Vue不能检测数组的哪些变动？Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？"></a>Vue不能检测数组的哪些变动？Vue 怎么用 <code>vm.$set()</code> 解决对象新增属性不能响应的问题 ？</h4><ul><li><p>Vue 不能检测以下数组的变动：</p><ul><li><p>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</p></li><li><p>当你修改数组的长度时，例如：vm.items.length = newLength</p></li><li><p>解决办法：</p><ul><li><p>第一类问题</p>  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 法一：Vue.set</span><br>Vue.<span class="hljs-keyword">set</span>(vm.items, indexOfItem, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br><span class="hljs-comment">// 法二：Array.prototype.splice</span><br>vm.items.splice(indexOfItem, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br></code></pre></td></tr></table></figure></li><li><p>第二类问题，可使用 splice：</p>  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">vm.items.splice(<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li>vm.<code>$set</code> 的实现原理是：<ul><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul></li></ul><h4 id="Vue事件绑定原理是什么？"><a href="#Vue事件绑定原理是什么？" class="headerlink" title="Vue事件绑定原理是什么？"></a>Vue事件绑定原理是什么？</h4><ul><li>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的<code>$on</code>实现的。</li></ul><h4 id="说一下虚拟Dom以及key属性的作用"><a href="#说一下虚拟Dom以及key属性的作用" class="headerlink" title="说一下虚拟Dom以及key属性的作用"></a>说一下虚拟Dom以及key属性的作用</h4><ul><li>由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的产生原因。</li><li>Virtual DOM本质就是用一个<strong>原生的JS对象去描述一个DOM节点</strong>。是对真实DOM的一层抽象。(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)</li><li>虚拟 DOM 的实现原理主要包括以下 3 部分：<ul><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li><li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li><li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ul></li><li>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速<ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li><li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul></li></ul><h4 id="为什么不建议用index作为key"><a href="#为什么不建议用index作为key" class="headerlink" title="为什么不建议用index作为key?"></a>为什么不建议用index作为key?</h4><ul><li>不建议 用index 作为 key，和没写基本上没区别，因为不管你数组的顺序怎么颠倒，index 都是 0, 1, 2 这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作</li></ul><h3 id="生命周期篇"><a href="#生命周期篇" class="headerlink" title="生命周期篇"></a>生命周期篇</h3><h4 id="说一下你对Vue的生命周期的理解"><a href="#说一下你对Vue的生命周期的理解" class="headerlink" title="说一下你对Vue的生命周期的理解"></a>说一下你对Vue的生命周期的理解</h4><ul><li>简单回答<ul><li>beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed。</li><li>keep-alive 有自己独立的钩子函数 activated 和 deactivated。</li></ul></li><li>复杂回答</li></ul><table><thead><tr><th><div style="width:120px">生命周期</div></th><th>发生了什么</th></tr></thead><tbody><tr><td>beforeCreate</td><td>在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问</td></tr><tr><td><strong>created</strong></td><td>在实例创建完成后发生，当前阶段已经<strong>完成了数据观测</strong>，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些<strong>初始数据的获取</strong>，在当前阶段无法与Dom进行交互，如果非要想，可以通过<code>vm.$nextTick</code>来访问Dom</td></tr><tr><td>beforeMount</td><td>发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated</td></tr><tr><td><strong>mounted</strong></td><td>在挂载完成后发生，在当前阶段，<strong>真实的Dom挂载完毕</strong>，<strong>数据完成双向绑定</strong>，<strong>可以访问到Dom节点</strong>，使用<code>$refs</code>属性对Dom进行操作</td></tr><tr><td>beforeUpdate</td><td>发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染</td></tr><tr><td>updated</td><td>发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新</td></tr><tr><td><strong>beforeDestroy</strong></td><td>发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行<strong>善后收尾</strong>工作，<strong>比如清除计时器</strong></td></tr><tr><td>destroyed</td><td>发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁</td></tr><tr><td>activited keep-alive 专属</td><td>组件被激活时调用</td></tr><tr><td>deactivated keep-alive 专属</td><td>组件被销毁时调用</td></tr></tbody></table><h4 id="Vue中组件生命周期调用顺序是什么样的？"><a href="#Vue中组件生命周期调用顺序是什么样的？" class="headerlink" title="Vue中组件生命周期调用顺序是什么样的？"></a>Vue中组件生命周期调用顺序是什么样的？</h4><ul><li>组件的调用顺序都是先父后子,渲染完成的顺序是先子后父。</li><li>组件的销毁操作是先父后子，销毁完成的顺序是先子后父。</li></ul><h4 id="在什么阶段才能访问操作DOM？"><a href="#在什么阶段才能访问操作DOM？" class="headerlink" title="在什么阶段才能访问操作DOM？"></a>在什么阶段才能访问操作DOM？</h4><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p><h4 id="你的接口请求一般放在哪个生命周期中？"><a href="#你的接口请求一般放在哪个生命周期中？" class="headerlink" title="你的接口请求一般放在哪个生命周期中？"></a>你的接口请求一般放在哪个生命周期中？</h4><ul><li>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</li><li>但是推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：<ul><li>能更快获取到服务端数据，减少页面loading 时间；</li><li>ssr不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li></ul></li></ul><h3 id="路由篇"><a href="#路由篇" class="headerlink" title="路由篇"></a>路由篇</h3><h4 id="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"><a href="#vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？" class="headerlink" title="vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？"></a>vue路由hash模式和history模式实现原理分别是什么，他们的区别是什么？</h4><ul><li>hash 模式：<ul><li>#后面 hash 值的变化，不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面</li><li>通过监听 <strong>hashchange</strong> 事件可以知道 hash 发生了哪些变化，然后根据 hash 变化来实现更新页面部分内容的操作。</li></ul></li><li>history 模式：<ul><li>history 模式的实现，主要是 HTML5 标准发布的两个 API，<strong>pushState</strong> 和 <strong>replaceState</strong>，这两个 API 可以在改变 url，但是不会发送请求。这样就可以监听 url 变化来实现更新页面部分内容的操作</li></ul></li><li>区别<ul><li>url 展示上，hash 模式有“#”，history 模式没有</li><li>刷新页面时，hash 模式可以正常加载到 hash 值对应的页面，而 history 没有处理的话，会返回 404，一般需要后端将所有页面都配置重定向到首页路由</li><li>兼容性，hash 可以支持低版本浏览器和 IE。</li></ul></li></ul><h4 id="路由懒加载是什么意思？如何实现路由懒加载？"><a href="#路由懒加载是什么意思？如何实现路由懒加载？" class="headerlink" title="路由懒加载是什么意思？如何实现路由懒加载？"></a>路由懒加载是什么意思？如何实现路由懒加载？</h4><ul><li><p>路由懒加载的含义：把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件</p></li><li><p>实现：结合 Vue 的异步组件和 Webpack 的代码分割功能</p><ul><li><ol><li>可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)</li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Foo = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve(&#123; <span class="hljs-comment">/* 组件定义对象 */</span> &#125;)<br></code></pre></td></tr></table></figure></li><li><ol start="2"><li>在 Webpack 2 中，我们可以使用动态 import语法来定义代码分块点 (split point)<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">import</span><span class="hljs-params">(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)</span></span> <span class="hljs-comment">// 返回 Promise</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件</p>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const Foo =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> import(&#x27;./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Foo</span>.</span></span>vue&#x27;)<br>const router = <span class="hljs-keyword">new</span> <span class="hljs-constructor">VueRouter(&#123; <span class="hljs-params">routes</span>: [ &#123; <span class="hljs-params">path</span>: &#x27;<span class="hljs-operator">/</span><span class="hljs-params">foo</span>&#x27;, <span class="hljs-params">component</span>: Foo &#125; ]&#125;)</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用命名 chunk，和webpack中的魔法注释就可以把某个路由下的所有组件都打包在同个异步块 (chunk) 中</p></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">chunkconst Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> import(<span class="hljs-comment">/* webpackChunkName: &quot;group-foo&quot; */</span> <span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="Vue-router-导航守卫有哪些"><a href="#Vue-router-导航守卫有哪些" class="headerlink" title="Vue-router 导航守卫有哪些"></a>Vue-router 导航守卫有哪些</h4><ul><li>全局前置/钩子：beforeEach、beforeResolve、afterEach</li><li>路由独享的守卫：beforeEnter</li><li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul><hr><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h4 id="说说vue和react的异同"><a href="#说说vue和react的异同" class="headerlink" title="说说vue和react的异同"></a>说说vue和react的异同</h4><ul><li>同<ul><li>使用 Virtual DOM</li><li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li><li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li></ul></li><li>异<ul><li>在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树（除非使用PureComponent/shouldComponentUpdate），在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染</li><li>在 React 中，一切都是 JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理</li><li>Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统，所以有更丰富的生态系统</li><li>Vue 提供了CLI 脚手架，能让你通过交互式的脚手架引导非常容易地构建项目。你甚至可以使用它快速开发组件的原型。React 在这方面也提供了create-react-app，但是现在还存在一些局限性</li><li>React Native 能使你用相同的组件模型编写有本地渲染能力的 APP，Vue 和Weex会进行官方合作，Weex 是阿里巴巴发起的跨平台用户界面开发框架，同时也正在 Apache 基金会进行项目孵化，另一个选择是NativeScript-Vue，一个用 Vue.js 构建完全原生应用的NativeScript插件</li></ul></li></ul><h4 id="什么是-mixin-？"><a href="#什么是-mixin-？" class="headerlink" title="什么是 mixin ？"></a>什么是 mixin ？</h4><ul><li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li><li>如果你希望再多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li><li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li></ul><h4 id="在-Vue-实例中编写生命周期-hook-或其他-option-properties-时，为什么不使用箭头函数-？"><a href="#在-Vue-实例中编写生命周期-hook-或其他-option-properties-时，为什么不使用箭头函数-？" class="headerlink" title="在 Vue 实例中编写生命周期 hook 或其他 option/properties 时，为什么不使用箭头函数 ？"></a>在 Vue 实例中编写生命周期 hook 或其他 option/properties 时，为什么不使用箭头函数 ？</h4><ul><li>箭头函数自已没有定义 this 上下文中。</li><li>当你在 Vue 程序中使用箭头函数 ( =&gt; ) 时，this 关键字病不会绑定到 Vue 实例，因此会引发错误。所以强烈建议改用标准函数声明。</li></ul><h4 id="Vue模版编译原理知道吗，能简单说一下吗？"><a href="#Vue模版编译原理知道吗，能简单说一下吗？" class="headerlink" title="Vue模版编译原理知道吗，能简单说一下吗？"></a>Vue模版编译原理知道吗，能简单说一下吗？</h4><p>简单说，Vue的编译过程就是将template转化为render函数的过程。会经历以下阶段（生成AST树/优化/codegen）：</p><ul><li>首先解析模版，生成AST语法树(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。</li><li>Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。</li><li>编译的最后一步是将优化后的AST树转换为可执行的代码。</li></ul><h4 id="diff算法说一下"><a href="#diff算法说一下" class="headerlink" title="diff算法说一下"></a>diff算法说一下</h4><ul><li>同级比较，再比较子节点</li><li>先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li><li>比较都有子节点的情况(核心diff)</li><li>递归比较子节点</li></ul><h4 id="说说你对keep-alive组件的了解"><a href="#说说你对keep-alive组件的了解" class="headerlink" title="说说你对keep-alive组件的了解"></a>说说你对keep-alive组件的了解</h4><ul><li>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：<ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul></li></ul><h4 id="说说你对SSR的了解"><a href="#说说你对SSR的了解" class="headerlink" title="说说你对SSR的了解"></a>说说你对SSR的了解</h4><ul><li>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</li><li>SSR的优势<ul><li>更好的SEO</li><li>首屏加载速度更快</li></ul></li><li>SSR的缺点<ul><li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子</li><li>当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境</li><li>更多的服务端负载</li></ul></li></ul><h4 id="你都做过哪些Vue的性能优化？"><a href="#你都做过哪些Vue的性能优化？" class="headerlink" title="你都做过哪些Vue的性能优化？"></a>你都做过哪些Vue的性能优化？</h4><ul><li>编码阶段<ul><li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li><li>v-if和v-for不能连用</li><li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li><li>SPA 页面采用keep-alive缓存组件</li><li>在更多的情况下，使用v-if替代v-show</li><li>key保证唯一</li><li>使用路由懒加载、异步组件</li><li>防抖、节流</li><li>第三方模块按需导入</li><li>长列表滚动到可视区域动态加载</li><li>图片懒加载</li></ul></li><li>SEO优化<ul><li>预渲染</li><li>服务端渲染SSR</li></ul></li><li>打包优化<ul><li>压缩代码</li><li>Tree Shaking/Scope Hoisting</li><li>使用cdn加载第三方模块</li><li>多线程打包happypack</li><li>splitChunks抽离公共文件</li><li>sourceMap优化</li></ul></li><li>用户体验<ul><li>骨架屏</li><li>PWA</li><li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li></ul></li></ul><h4 id="vue2-x中如何监测数组变化？"><a href="#vue2-x中如何监测数组变化？" class="headerlink" title="vue2.x中如何监测数组变化？"></a>vue2.x中如何监测数组变化？</h4><ul><li>使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，当调用数组api时，可以通知依赖更新。</li><li>如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。</li></ul><h4 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h4><ul><li>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</li><li>优点：<ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul></li><li>缺点：<ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul></li></ul><h4 id="对于即将到来的-vue3-0-特性你有什么了解的吗？"><a href="#对于即将到来的-vue3-0-特性你有什么了解的吗？" class="headerlink" title="对于即将到来的 vue3.0 特性你有什么了解的吗？"></a>对于即将到来的 vue3.0 特性你有什么了解的吗？</h4><ul><li>监测机制的改变<ul><li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li><li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li></ul></li><li>只能监测属性，不能监测对象<ul><li>检测属性的添加和删除；</li><li>检测数组索引和长度的变更；</li><li>支持 Map、Set、WeakMap 和 WeakSet。</li></ul></li><li>模板<ul><li>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li><li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li></ul></li><li>对象式的组件声明方式<ul><li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li><li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li></ul></li><li>其它方面的更改<ul><li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li><li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li><li>基于 tree shaking 优化，提供了更多的内置功能。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3.0</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象</title>
    <link href="/2020/06/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/js/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3/"/>
    <url>/2020/06/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/js/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h3><h4 id="es6中class定义的类和es5中的构造函数有什么区别"><a href="#es6中class定义的类和es5中的构造函数有什么区别" class="headerlink" title="es6中class定义的类和es5中的构造函数有什么区别?"></a>es6中class定义的类和es5中的构造函数有什么区别?</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// es6中的类形如</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(x, y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br><br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-keyword">this</span>.x + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-keyword">this</span>.y + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类可以看作一个<strong>语法糖</strong>，是构造函数的另外一种写法</li><li>类只是让对象原型的写法更加清晰，更像<strong>面向对象编程</strong>的语法</li><li><strong>constructor方法</strong>，就是构造方法（es5中的构造函数），this关键字代表实例对象</li><li>类的所有方法都定义在<strong>类的prototype属性</strong>上面</li><li>类的内部所有定义的方法，都是<strong>不可枚举</strong>的</li><li><strong>类必须使用new调用</strong>，否则会报错，而普通构造函数不用new也可以执行</li></ul><h4 id="类的constructor方法是什么？"><a href="#类的constructor方法是什么？" class="headerlink" title="类的constructor方法是什么？"></a>类的constructor方法是什么？</h4><ul><li>是类的默认方法，new命令生成对象实例时自动调用该方法<blockquote><p>一个类必须有constructor方法,如果没有显式定义，一个空的constructor方法会被默认添加</p></blockquote></li><li>默认返回实例对象，可以制定返回另一个对象</li></ul><h4 id="类的实例有什么需要注意的？"><a href="#类的实例有什么需要注意的？" class="headerlink" title="类的实例有什么需要注意的？"></a>类的实例有什么需要注意的？</h4><ul><li>实例的属性除非显示定义在其本身，否则都是定义在原型上</li><li>类的所有实例共享一个原型对象</li></ul><h4 id="类中取值函数（getter）和存值函数（setter）的使用"><a href="#类中取值函数（getter）和存值函数（setter）的使用" class="headerlink" title="类中取值函数（getter）和存值函数（setter）的使用"></a>类中取值函数（getter）和存值函数（setter）的使用</h4><ul><li>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</li><li>存值函数和取值函数是设置在属性的 Descriptor 对象上的  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">get</span> <span class="hljs-title">prop</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">set</span> <span class="hljs-title">prop</span>(<span class="hljs-params">value</span>) &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span>+value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="使用类的时候需要注意的点"><a href="#使用类的时候需要注意的点" class="headerlink" title="使用类的时候需要注意的点"></a>使用类的时候需要注意的点</h4><ol><li><p>类和模块的内部本来就是严格模式，所以不需要用use strict指定运行模式</p></li><li><p>不存在变量提升</p></li><li><p>类只是对普通构造函数的一层包裹，所以函数的许多特性都被class继承</p></li><li><p>Generator方法。如果在某个方法前面加上星号（*）,就表示该方法是一个Generator函数</p></li><li><p>this的指向问题</p><ul><li><p>类的方法内部如果含有this,默认指向类的实例，但因为方法中的this的确是指向实例，但是如果将该方法单独提取出来的话，this会指向该方法运行时所在的函数（class内部是严格模式，所以this指向undefined）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params">name = <span class="hljs-string">&quot;there&quot;</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.print(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger();<br><span class="hljs-keyword">const</span> &#123; printName &#125; = logger;<br>logger.printName(); <span class="hljs-comment">//ok</span><br>printName(); <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure></li><li><p>解决办法</p><ol><li><p>构造方法中绑定this</p><blockquote><p>constructor() {this.printName = this.printName.bind(this);}</p></blockquote></li><li><p>使用箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.getThis = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = <span class="hljs-keyword">new</span> Obj();<br>myObj.getThis() === myObj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>使用proxy，获取方法的时候，自动绑定this</p></li></ol></li></ul></li></ol><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li><strong>定义</strong>：在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是<strong>直接通过类</strong>来调用，这就称为“静态方法”。</li><li>如果静态方法包含this,这个this指向的是类，而不是实例</li><li>父类的静态方法，可以被子类继承，子类可以调用这个方法</li><li>静态方法也可以从super对象上调用</li></ul><h4 id="实例属性的写法"><a href="#实例属性的写法" class="headerlink" title="实例属性的写法"></a>实例属性的写法</h4><ul><li><p>除了可以定义在constructor的this上面，也可以定义在类的最顶层</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncreasingCounter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._count = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">/** _count=0 和上面这种方法带来的效果一样</span><br><span class="hljs-comment">   ** 注释掉的这种写法的好处是，所有的实例对象的属性都定义在类的头部，</span><br><span class="hljs-comment">   ** 看上去比较整齐，一眼就能看出这个类有哪些实例属性</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Getting the current value!&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._count;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._count++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4></li><li><p><strong>定义</strong>：指的是class本身的属性，而不是定义在实例对象的（this）上的属性</p></li><li><p>现有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字</p>  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 老写法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>Foo.prop = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 新写法-es7</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> prop = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h4><blockquote><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p></blockquote></li><li><p>私有属性语法</p><ul><li>声明私有属性直接使用#开头作为属性名，声明不能在私有属性前加this，但是使用时必须使用this调用</li><li>不能在子类调用父类的私有属性，但是可以在子类定义与父类同名的私有属性，并且互不干扰，但最好不要这样做</li><li>不能在constructor中定义私有属性和方法</li></ul></li><li><p>es7实现，通过#来声明</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>    #x = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x = <span class="hljs-number">0</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.num = <span class="hljs-built_in">this</span>.#x; <span class="hljs-comment">//公有属性可以获取私有属性的值</span><br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title">x</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-built_in">this</span>.#x +=value; <span class="hljs-comment">//这里可以理解为公有方法内部给私有属性写入值</span><br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">x</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#x; <span class="hljs-comment">//这里可以理解为公有方法内部读取私有属性的值</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.num + <span class="hljs-built_in">this</span>.#x); <span class="hljs-comment">//这里可以理解为公有方法读取私有属性的值</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">y</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 子类方法不能直接使用父类的私有属性，babel插件无法编译</span><br>        <span class="hljs-comment">//  return this.#x;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<strong>私有属性</strong>需要注意的点</p><ul><li><strong>实例对象可以调用类定义的公开方法获取和修改私有属性，可以调用类的公开方法执行私有方法。实例对象一定要通过类的公有方法才能使用私有属性和方法</strong></li><li>静态属性的this指向类，私有属性的this指向实例对象</li></ul></li></ul><h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><h4 id="怎么实现class的继承？"><a href="#怎么实现class的继承？" class="headerlink" title="怎么实现class的继承？"></a>怎么实现class的继承？</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  constructor(x, y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>  constructor(x, y, color) &#123;<br>    <span class="hljs-keyword">this</span>.color = color; <span class="hljs-comment">// ReferenceError</span><br>    <span class="hljs-keyword">super</span>(x, y);<br>    <span class="hljs-keyword">this</span>.color = color; <span class="hljs-comment">// 正确</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多</li><li>super关键字，它在这里表示父类的构造函数，用来新建父类的this对象<ul><li>super作为函数调用时，代表父类的构造函数，es6要求子类的构造函数必须执行一次super函数（super执行时指向子类的构造函数）</li><li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类<blockquote><p>由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的</p></blockquote></li></ul></li><li>子类必须在constructor方法中调用super方法，否则新建实例时会报错<blockquote><p>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p></blockquote></li><li>不管有没有显式定义，任何一个子类都有constructor方法。如果子类没有定义constructor方法，这个方法会被默认添加</li><li>父类的静态方法，也会被子类继承</li></ul><h3 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h3><ul><li><p>是一种函数，写成@ + 函数名。可以放在类和类的方法的定义前面</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4></li><li><p>是一个对类进行处理的函数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@decorator</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br>A = decorator(A) || A;<br></code></pre></td></tr></table></figure></li><li><p>装饰器函数的第一个参数就是所要装饰的目标类</p><ul><li>为类添加一个静态属性  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">testable</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">target</span>.prototype.isTestable = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-meta">@testable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestableClass</span> </span>&#123;&#125;<br>let obj = <span class="hljs-keyword">new</span> MyTestableClass();<br>obj.isTestable <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>如果一个参数不够用，可以在装饰器外面再封装一层函数，装饰器可以接受参数，这就等于可以修改装饰器的行为</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">testable</span><span class="hljs-params">(isTestable)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">target</span>.isTestable = isTestable;<br>  &#125;;<br>&#125;<br><span class="hljs-meta">@testable</span>(<span class="hljs-keyword">true</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestableClass</span> </span>&#123;&#125;<br>MyTestableClass.isTestable; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。装饰器的本质就是编译时执行的函数</p></blockquote></li><li><p>在实例上添加属性，通过目标类的prototype对象操作</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">testable</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">target</span>.prototype.isTestable = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-meta">@testable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestableClass</span> </span>&#123;&#125;<br>let obj = <span class="hljs-keyword">new</span> MyTestableClass();<br>obj.isTestable <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span> </span>&#123;<br>  <span class="hljs-meta">@log</span><br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">target, name, descriptor</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> oldValue = descriptor.value;<br>  descriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Calling <span class="hljs-subst">$&#123;name&#125;</span> with`</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">return</span> oldValue.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><span class="hljs-keyword">const</span> math = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Math</span>();<br><span class="hljs-comment">// passed parameters should get logged now</span><br>math.add(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li>一共接受三个参数<ul><li>target：类的原型对象</li><li>name：所要装饰的属性名</li><li>descriptor：该属性的描述对象</li></ul></li><li>同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面向对象</tag>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解es6装饰器</title>
    <link href="/2020/06/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/es6+/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3es6%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2020/06/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/es6+/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3es6%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文需要提前掌握es5中构造函数相关知识点：<a href="https://juejin.im/post/5ec6464a518825434062f38e">我是知识点</a></p></blockquote><h3 id="class基本语法"><a href="#class基本语法" class="headerlink" title="class基本语法"></a>class基本语法</h3><h4 id="es6中class定义的类和es5中的构造函数有什么区别"><a href="#es6中class定义的类和es5中的构造函数有什么区别" class="headerlink" title="es6中class定义的类和es5中的构造函数有什么区别?"></a>es6中class定义的类和es5中的构造函数有什么区别?</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// es6中的类形如</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(x, y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br><br>  toString() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-keyword">this</span>.x + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-keyword">this</span>.y + <span class="hljs-string">&#x27;)&#x27;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类可以看作一个<strong>语法糖</strong>，是构造函数的另外一种写法</li><li>类只是让对象原型的写法更加清晰，更像<strong>面向对象编程</strong>的语法</li><li><strong>constructor方法</strong>，就是构造方法（es5中的构造函数），this关键字代表实例对象</li><li>类的所有方法都定义在<strong>类的prototype属性</strong>上面</li><li>类的内部所有定义的方法，都是<strong>不可枚举</strong>的</li><li><strong>类必须使用new调用</strong>，否则会报错，而普通构造函数不用new也可以执行</li></ul><h4 id="类的constructor方法是什么？"><a href="#类的constructor方法是什么？" class="headerlink" title="类的constructor方法是什么？"></a>类的constructor方法是什么？</h4><ul><li>是类的默认方法，new命令生成对象实例时自动调用该方法<blockquote><p>一个类必须有constructor方法,如果没有显式定义，一个空的constructor方法会被默认添加</p></blockquote></li><li>默认返回实例对象，可以制定返回另一个对象</li></ul><h4 id="类的实例有什么需要注意的？"><a href="#类的实例有什么需要注意的？" class="headerlink" title="类的实例有什么需要注意的？"></a>类的实例有什么需要注意的？</h4><ul><li>实例的属性除非显示定义在其本身，否则都是定义在原型上</li><li>类的所有实例共享一个原型对象</li></ul><h4 id="类中取值函数（getter）和存值函数（setter）的使用"><a href="#类中取值函数（getter）和存值函数（setter）的使用" class="headerlink" title="类中取值函数（getter）和存值函数（setter）的使用"></a>类中取值函数（getter）和存值函数（setter）的使用</h4><ul><li>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为</li><li>存值函数和取值函数是设置在属性的 Descriptor 对象上的  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">get</span> <span class="hljs-title">prop</span>() &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">set</span> <span class="hljs-title">prop</span>(<span class="hljs-params">value</span>) &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span>+value);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="使用类的时候需要注意的点"><a href="#使用类的时候需要注意的点" class="headerlink" title="使用类的时候需要注意的点"></a>使用类的时候需要注意的点</h4><ol><li><p>类和模块的内部本来就是严格模式，所以不需要用use strict指定运行模式</p></li><li><p>不存在变量提升</p></li><li><p>类只是对普通构造函数的一层包裹，所以函数的许多特性都被class继承</p></li><li><p>Generator方法。如果在某个方法前面加上星号（*）,就表示该方法是一个Generator函数</p></li><li><p>this的指向问题</p><ul><li><p>类的方法内部如果含有this,默认指向类的实例，但因为方法中的this的确是指向实例，但是如果将该方法单独提取出来的话，this会指向该方法运行时所在的函数（class内部是严格模式，所以this指向undefined）</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">printName</span>(<span class="hljs-params">name = <span class="hljs-string">&quot;there&quot;</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.print(<span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>`</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger();<br><span class="hljs-keyword">const</span> &#123; printName &#125; = logger;<br>logger.printName(); <span class="hljs-comment">//ok</span><br>printName(); <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure></li><li><p>解决办法</p><ol><li><p>构造方法中绑定this</p><blockquote><p>constructor() {this.printName = this.printName.bind(this);}</p></blockquote></li><li><p>使用箭头函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Obj</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.getThis = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> myObj = <span class="hljs-keyword">new</span> Obj();<br>myObj.getThis() === myObj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>使用proxy，获取方法的时候，自动绑定this</p></li></ol></li></ul></li></ol><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li><strong>定义</strong>：在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是<strong>直接通过类</strong>来调用，这就称为“静态方法”。</li><li>如果静态方法包含this,这个this指向的是类，而不是实例</li><li>父类的静态方法，可以被子类继承，子类可以调用这个方法</li><li>静态方法也可以从super对象上调用</li></ul><h4 id="实例属性的写法"><a href="#实例属性的写法" class="headerlink" title="实例属性的写法"></a>实例属性的写法</h4><ul><li><p>除了可以定义在constructor的this上面，也可以定义在类的最顶层</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IncreasingCounter</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._count = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">/** _count=0 和上面这种方法带来的效果一样</span><br><span class="hljs-comment">   ** 注释掉的这种写法的好处是，所有的实例对象的属性都定义在类的头部，</span><br><span class="hljs-comment">   ** 看上去比较整齐，一眼就能看出这个类有哪些实例属性</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Getting the current value!&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._count;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>._count++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4></li><li><p><strong>定义</strong>：指的是class本身的属性，而不是定义在实例对象的（this）上的属性</p></li><li><p>现有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字</p>  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 老写法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>Foo.prop = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 新写法-es7</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> prop = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="headerlink" title="私有方法和私有属性"></a>私有方法和私有属性</h4><blockquote><p>私有方法和私有属性，是只能在类的内部访问的方法和属性，外部不能访问。这是常见需求，有利于代码的封装，但 ES6 不提供，只能通过变通方法模拟实现。</p></blockquote></li><li><p>私有属性语法</p><ul><li>声明私有属性直接使用#开头作为属性名，声明不能在私有属性前加this，但是使用时必须使用this调用</li><li>不能在子类调用父类的私有属性，但是可以在子类定义与父类同名的私有属性，并且互不干扰，但最好不要这样做</li><li>不能在constructor中定义私有属性和方法</li></ul></li><li><p>es7实现，通过#来声明</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>&#123;<br>    #x = <span class="hljs-number">10</span>;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x = <span class="hljs-number">0</span></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.num = <span class="hljs-built_in">this</span>.#x; <span class="hljs-comment">//公有属性可以获取私有属性的值</span><br>    &#125;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title">x</span>(<span class="hljs-params">value</span>)&#123;<br>        <span class="hljs-built_in">this</span>.#x +=value; <span class="hljs-comment">//这里可以理解为公有方法内部给私有属性写入值</span><br>    &#125;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title">x</span>()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.#x; <span class="hljs-comment">//这里可以理解为公有方法内部读取私有属性的值</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.num + <span class="hljs-built_in">this</span>.#x); <span class="hljs-comment">//这里可以理解为公有方法读取私有属性的值</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fun</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>()<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">y</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">// 子类方法不能直接使用父类的私有属性，babel插件无法编译</span><br>        <span class="hljs-comment">//  return this.#x;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用<strong>私有属性</strong>需要注意的点</p><ul><li><strong>实例对象可以调用类定义的公开方法获取和修改私有属性，可以调用类的公开方法执行私有方法。实例对象一定要通过类的公有方法才能使用私有属性和方法</strong></li><li>静态属性的this指向类，私有属性的this指向实例对象</li></ul></li></ul><h3 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h3><h4 id="怎么实现class的继承？"><a href="#怎么实现class的继承？" class="headerlink" title="怎么实现class的继承？"></a>怎么实现class的继承？</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>  constructor(x, y) &#123;<br>    <span class="hljs-keyword">this</span>.x = x;<br>    <span class="hljs-keyword">this</span>.y = y;<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>  constructor(x, y, color) &#123;<br>    <span class="hljs-keyword">this</span>.color = color; <span class="hljs-comment">// ReferenceError</span><br>    <span class="hljs-keyword">super</span>(x, y);<br>    <span class="hljs-keyword">this</span>.color = color; <span class="hljs-comment">// 正确</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多</li><li>super关键字，它在这里表示父类的构造函数，用来新建父类的this对象<ul><li>super作为函数调用时，代表父类的构造函数，es6要求子类的构造函数必须执行一次super函数（super执行时指向子类的构造函数）</li><li>super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类<blockquote><p>由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的</p></blockquote></li></ul></li><li>子类必须在constructor方法中调用super方法，否则新建实例时会报错<blockquote><p>这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p></blockquote></li><li>不管有没有显式定义，任何一个子类都有constructor方法。如果子类没有定义constructor方法，这个方法会被默认添加</li><li>父类的静态方法，也会被子类继承</li></ul><h3 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h3><ul><li><p>是一种函数，写成@ + 函数名。可以放在类和类的方法的定义前面</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4></li><li><p>是一个对类进行处理的函数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@decorator</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br>A = decorator(A) || A;<br></code></pre></td></tr></table></figure></li><li><p>装饰器函数的第一个参数就是所要装饰的目标类</p><ul><li>为类添加一个静态属性  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">testable</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">target</span>.prototype.isTestable = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-meta">@testable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestableClass</span> </span>&#123;&#125;<br>let obj = <span class="hljs-keyword">new</span> MyTestableClass();<br>obj.isTestable <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>如果一个参数不够用，可以在装饰器外面再封装一层函数，装饰器可以接受参数，这就等于可以修改装饰器的行为</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">testable</span><span class="hljs-params">(isTestable)</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">target</span>.isTestable = isTestable;<br>  &#125;;<br>&#125;<br><span class="hljs-meta">@testable</span>(<span class="hljs-keyword">true</span>)<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestableClass</span> </span>&#123;&#125;<br>MyTestableClass.isTestable; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><blockquote><p>装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。装饰器的本质就是编译时执行的函数</p></blockquote></li><li><p>在实例上添加属性，通过目标类的prototype对象操作</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function">function <span class="hljs-title">testable</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">target</span>.prototype.isTestable = <span class="hljs-keyword">true</span>;<br>&#125;<br><span class="hljs-meta">@testable</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTestableClass</span> </span>&#123;&#125;<br>let obj = <span class="hljs-keyword">new</span> MyTestableClass();<br>obj.isTestable <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Math</span> </span>&#123;<br>  <span class="hljs-meta">@log</span><br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">target, name, descriptor</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> oldValue = descriptor.value;<br>  descriptor.value = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Calling <span class="hljs-subst">$&#123;name&#125;</span> with`</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">return</span> oldValue.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> descriptor;<br>&#125;<br><span class="hljs-keyword">const</span> math = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Math</span>();<br><span class="hljs-comment">// passed parameters should get logged now</span><br>math.add(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><ul><li>一共接受三个参数<ul><li>target：类的原型对象</li><li>name：所要装饰的属性名</li><li>descriptor：该属性的描述对象</li></ul></li><li>同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>es6+</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es6+</tag>
      
      <tag>面向对象</tag>
      
      <tag>class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css基础</title>
    <link href="/2020/06/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/css-base/"/>
    <url>/2020/06/07/%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/css/css-base/</url>
    
    <content type="html"><![CDATA[<h4 id="垂直居中的方案"><a href="#垂直居中的方案" class="headerlink" title="垂直居中的方案"></a>垂直居中的方案</h4><ul><li><strong>弹性盒</strong><ul><li>display:flex</li><li>align-items:center</li><li>justify-content:center</li></ul></li><li><strong>translate</strong><ul><li>position: absolute</li><li>top: 50%</li><li>left: 50%</li><li><strong>transform: translate(-50%,-50%)</strong></li></ul></li><li><strong>相对定位</strong><ul><li>position: absolute</li><li>top/right/bottom/left:0</li><li>margin:auto</li></ul></li><li><strong>table+vertical-align</strong><ul><li>display: table-cell</li><li>vertical-align: middle<h4 id="清除浮动和BFC"><a href="#清除浮动和BFC" class="headerlink" title="清除浮动和BFC"></a>清除浮动和BFC</h4></li></ul></li><li><strong>清除浮动原理</strong><ul><li>清除浮动代码<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span>:after&#123;<br>    content:<span class="hljs-string">&#x27;&#x27;</span>;<br>    diaplay:block;<br>    <span class="hljs-attribute">clear</span>:both<br>&#125;<br>//兼容ie低版本<br><span class="hljs-selector-class">.clearfix</span>&#123;<br>    *zoom:<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>主要属性=&gt;<strong>clear:both  规定在左右两侧不允许浮动元素</strong></li><li><strong>display:block</strong>  <strong>clear只能在块级元素上起作用</strong></li><li>visibility:hidden/height:0  只要content的值为空，写不写都无所谓</li></ul></li><li><strong>BFC定义</strong><ul><li>块级格式化上下文，是一个独立的渲染区域</li><li>让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</li></ul></li><li><strong>触发BFC条件</strong><ul><li>根元素</li><li>position: absolute/fixed</li><li>display: inline-block / table</li><li>float 元素</li><li>ovevflow !== visible</li></ul></li><li><strong>BFC规则</strong><ul><li>属于同一个 BFC 的两个相邻 Box 垂直排列</li><li>属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠</li><li>BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外)</li><li>BFC 的区域不会与 float 的元素区域重叠</li><li>计算 BFC 的高度时，浮动子元素也参与计算</li><li>文字层不会被浮动层覆盖，环绕于周围</li></ul></li><li><strong>BFC应用</strong><ul><li>阻止margin重叠</li><li>可以包含浮动元素 —— 清除内部浮动 (清除浮动的原理是两个div都位于同一个 BFC 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li><li>其子元素的float/clear/vertical属性将失效<h4 id="css常用布局"><a href="#css常用布局" class="headerlink" title="css常用布局"></a>css常用布局</h4></li></ul></li><li>盒模型包括怪异盒模型</li><li>定位</li><li>流式布局</li><li>浮动布局</li><li>flex</li><li>grid布局</li></ul><h4 id="css权重"><a href="#css权重" class="headerlink" title="css权重"></a>css权重</h4><ul><li><strong>CSS权重</strong><ul><li>是指样式的优先级，有两条或多条样式作用于一个元素</li><li>权重高的那条样式对元素起作用</li><li>权重相同的，后写的样式会覆盖前面写的样式。</li></ul></li><li>权重的等级<ul><li><strong>!important</strong>,加在样式属性值后，权重值为<strong>10000</strong></li><li><strong>内联样式</strong>，如：style=””，权重值为1000</li><li><strong>ID选择器，如：#content，权重值为100</strong></li><li><strong>类，伪类和属性选择器</strong>，如：content、:hover权重值为10</li><li><strong>标签选择器和伪元素选择器</strong>，如：div/p/:before权重值为1</li><li>通用选择器（ * ) 、子选择器（&gt;）、相邻选择器（+）、同胞选择器（~）、权重值为0</li></ul></li></ul><h4 id="px-em-rem的区别"><a href="#px-em-rem的区别" class="headerlink" title="px/em/rem的区别"></a>px/em/rem的区别</h4><ul><li><strong>px</strong> (pixel，像素):相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li><li><strong>em</strong>(相对长度单位，相对于当前对象内文本的字体尺寸):em是相对长度单位。相对于当前对象内文本的字体尺寸（参考物是父元素的font-size）如当前父元素的字体尺寸未设置，则相对于浏览器的默认字体尺寸<ul><li>特点: em的值并不是固定的/em会继承父级元素的字体大小</li></ul></li><li><strong>rem</strong>（root em，根em）<ul><li>vue中使用postcss-px2rem</li><li>自动将vue项目中的px转换为rem</li><li>因为 postcss-plugin-px2rem 这个插件  配置选项上有  exclude 属性，它可以配置 是否对 某个文件夹下的所有css文件不进行从px到rem的转换。</li><li>rem是CSS3新增的一个相对单位，<strong>rem是相对于HTML根元素的字体大小</strong>（font-size）来计算的长度单位</li><li>优点：只需要设置<strong>根目录的大小</strong>就可以把整个页面的成比例的调好</li><li>rem兼容性：除了IE8及更早版本外，所有浏览器均已支持rem</li></ul></li><li>em与rem的区别：<ul><li>rem是相对于根元素（html）的字体大小，而em是相对于其父元素的字体大小</li><li>如何使 1rem=10px？在设置HTML{font-size：62.5%；}即可</li></ul></li><li>补充内容：<ul><li>vw是相对视口（viewport）的宽度而定的，长度等于视口宽度的1/100</li><li>vh是相对视口（viewport）的高度而定的，长度等于视口高度的1/100</li><li>vm其中最小的那个被均分为100单位的vm</li></ul></li></ul><h4 id="网站变灰–滤镜"><a href="#网站变灰–滤镜" class="headerlink" title="网站变灰–滤镜"></a>网站变灰–滤镜</h4><ul><li>filter:grayscale(100%)<h4 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h4></li><li><strong>单行文本溢出省略</strong><ul><li>overflow:hidden(文字超出限定宽度，则隐藏超出的内容)</li><li>white-space:nowrap(设置文字在一行显示，不能换行)</li><li>text-overflow:ellipsis(规定当文本溢出时，显示省略符号来代表被修剪得文本)</li></ul></li><li><strong>多行文本溢出省略</strong>(只适用于webkit内核)<ul><li>-webkit-line-clamp:2(用来限制在一个块元素现实的文本行数)</li><li>display:-webkit-box(和1结合使用，将对象作为弹性伸缩盒子显示)</li><li>-webkit-box-orient:vertical(和1结合使用，设置或检索伸缩对象的子元素的排列方式)</li><li>overflow:hidden</li><li>text-overflow:ellipsis</li></ul></li></ul><h4 id="伪类-伪元素"><a href="#伪类-伪元素" class="headerlink" title="伪类/伪元素"></a>伪类/伪元素</h4><ul><li><strong>伪元素</strong><ul><li>::fist-line为某个元素的第一行文字添加使用样式</li><li>::first-letter为某个元素的文字的首字母或第一个字添加使用样式</li><li>::before在某个元素之前插入一些内容</li><li>::after在某个元素之后插入一些内容</li><li>::selection对光标选中的元素添加样式</li></ul></li><li>伪类<ul><li>:link<ul><li>选取未访问过的超链接元素，只要点过的就会变色，从而标记哪个链接是访问过的,这个属性就是用来表示没访问过的链接</li></ul></li><li>:visited<ul><li>与前者相反，用来标记哪个链接是已经访问过的，防止重复点击</li></ul></li><li>:hover<ul><li>选取鼠标悬停的元素，经常用在PC端，当鼠标放在一个元素上面时的样式,移动端基本用不到</li></ul></li><li>:active<ul><li>选取点中的元素，希望按钮有反馈的时候 可以用它来标记操作反馈的样式</li><li>并不只可以用在按钮上</li></ul></li><li>:focus</li><li>:empty<ul><li>选取没有子元素的元素，比如选择空的span</li><li>要注意，就算有空格的化也不能算空，不会被这个伪类选中</li></ul></li><li>:checked<ul><li>选取勾选状态的input元素，只对radio/checkbox生效</li></ul></li><li>:disabled<ul><li>选取禁用的表单元素</li></ul></li><li>:first/last/nth-child/:nth-last-child(an+b)</li><li>:only-child(选取<strong>唯一</strong>子元素)</li><li>:not<ul><li>该伪类本身没有优先级</li><li>优先级由括号里面的内容决定<h4 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h4></li></ul></li></ul></li><li><strong>重绘</strong>:指当前页面的元素不脱离文档流，简单的进行样式的变化，如修改颜色背景，浏览器绘制样式等</li><li><strong>回流</strong>:指处于文档流中DOM的尺寸大小，位置或者某些属性发生变化时，导致浏览器重新渲染部分或者全部文档</li><li>回流比重绘消耗性能开支更大<h4 id="html5新特性"><a href="#html5新特性" class="headerlink" title="html5新特性"></a>html5新特性</h4></li><li>用于绘画的<strong>canvas</strong>元素</li><li>用于媒介回放的 <strong>video</strong> 和<strong>audio</strong>元素</li><li><strong>svg</strong>,地理定位</li><li>对本地离线存储的更好的支持<strong>localStorage</strong>(5M的存储空间&gt;&gt;cookies的4K)</li><li>语义化标签 article、footer、header、nav、section</li><li><strong>WebSocket</strong>长链接<h4 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h4></li><li><strong>伪元素</strong><ul><li>::first-line（首行）</li><li>::first-letter （首字）</li><li>::before 在某个元素之前插入一些内容</li><li>::after 在某个元素之后插入一些内容</li></ul></li><li><strong>盒模型</strong>（box-sizing: border-box怪异盒模型的运用）</li><li><strong>弹性盒子</strong><ul><li>定义<ul><li>一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式</li><li>弹性盒子由<strong>弹性容器</strong>(Flex container)和<strong>弹性子元素</strong>(Flex item)组成。</li><li>弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。</li></ul></li><li><strong>flex-direction</strong>  顺序指定了弹性子元素在父容器中的位置。<ul><li>row：横向从左到右排列（左对齐），默认的排列方式。</li><li>row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面</li><li>column：纵向排列。</li><li>column-reverse：反转纵向排列，从后往前排，最后一项排在最上面。</li></ul></li><li><strong>justify-content</strong> 属性(控制主轴)<ul><li>justify-content: flex-start | flex-end | center | space-between | space-around</li><li>flex-start 弹性项目向行头紧挨着填充。默认值</li><li>flex-end 弹性项目向行尾紧挨着填充。</li><li>center 弹性项目居中紧挨着填充。</li><li>space-between 弹性项目平均分布在该行上，两端对齐。</li><li>space-around 弹性项目平均分布在该行上，两边留有一半的间隔空间。</li></ul></li><li><strong>align-items</strong> 设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式<ul><li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li><li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li><li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。</li><li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li><li>stretch：默认值，自动将子元素拉伸成容器的高度</li></ul></li><li><strong>flex-wrap</strong>属性用于指定弹性盒子的子元素换行方式<ul><li>nowrap- 默认，弹性容器为单行。该情况下弹性子项可能会溢出容器。</li><li>wrap- 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行</li><li>wrap-reverse-反转 wrap 排列。</li></ul></li><li><strong>align-content</strong> 属性用于修改flex-wrap属性的行为。类似于align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。<ul><li>stretch- 默认。各行将会伸展以占用剩余的空间。</li><li>flex-start- 各行向弹性盒容器的起始位置堆叠。</li><li>flex-end- 各行向弹性盒容器的结束位置堆叠。</li><li>center-各行向弹性盒容器的中间位置堆叠。</li><li>space-between-各行在弹性盒容器中平均分布。</li><li>space-around- 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。</li></ul></li><li><strong>align-self</strong>属性用于设置弹性元素自身在侧轴（纵轴）方向上的对齐方式<ul><li>auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。</li><li>flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。</li><li>flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。</li><li>center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。</li><li>baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。</li><li>stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。</li></ul></li><li><strong>flex</strong> 属性用于指定弹性子元素如何分配空间</li><li><strong>flex-basis</strong> 用来设置子元素主轴方向的尺寸，eg:flex-basis:200px;</li></ul></li><li>背景和边框<ul><li><strong>border-radius</strong></li><li><strong>box-shadow</strong></li><li>border-image</li><li>background-size</li><li>background-origin</li><li>content-box</li><li>padding-box</li><li>border-box</li><li>多重背景background-image:url(bg_flower.gif),url(bg_flower_2.gif);</li><li>文本效果text-shadow（能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色）text-shadow: 5px 5px 5px #FF0000;</li><li><strong>word-wrap</strong>允许您允许文本强制文本进行换行 即使这意味着会对单词进行拆分</li></ul></li><li>字体<ul><li>将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上（之前是需要下载到本地的）</li><li>@font-face 规则中定义<ul><li>首先定义字体的名称（比如 myFirstFont）然后指向该字体文件</li></ul></li></ul></li><li><strong>2D/3D 转换</strong><ul><li>CSS3 转换，我们能够对元素进行移动、缩放、转动、拉长或拉伸</li><li>2D转换<ul><li><strong>translate()</strong>–translateX/Y<ul><li>transform: translate(50px,100px);把元素从左侧移动 50 像素，从顶端移动 100 像素</li></ul></li><li><strong>rotate()</strong>:transform: rotate(30deg);元素顺时针旋转给定的角度。允许负值，元素将逆时针旋转</li><li><strong>scale()</strong>–scaleX/Y transform: scale(2,4)把宽度转换为原始尺寸的 2 倍，把高度转换为原始高度的 4 倍。</li><li><strong>skew()</strong>–skewX/Y元素翻转给定的角度，根据给定的水平线（X 轴）和垂直线（Y 轴）参数<ul><li>transform: skew(30deg,20deg);围绕 X 轴把元素翻转 30 度，围绕 Y 轴翻转 20 度</li></ul></li><li><strong>matrix()</strong><ul><li>把所有 2D 转换方法组合在一起</li><li>matrix() 方法需要六个参数，包含数学函数，允许您：旋转、缩放、移动以及倾斜元素</li></ul></li></ul></li><li><strong>3D转换</strong><ul><li>translateX(x) /translateY(y)/translateZ(z)</li><li>scale3d(x,y,z)/scaleX(x)/scaleY(y)/scaleZ(z)</li><li>rotate3d(x,y,z,angle) /rotateX(angle)/rotateY(angle)/rotateZ(angle)</li></ul></li></ul></li><li><strong>transition 过渡效果</strong><ul><li>transition: property duration timing-function delay;</li><li>transition: 过渡动画</li><li>transition-property: 属性</li><li>transition-duration: 间隔</li><li>transition-timing-function: 曲线</li><li>transition-delay: 延迟</li></ul></li><li><strong>动画</strong><ul><li>@keyframes 创建动画规则（from-to/0%~100%）<ul><li> @keyframes myfirst{from {background: red;}to {background: yellow;}}</li></ul></li><li> animation: <strong>myfirst 5s linear 2s infinite alternate</strong>;</li><li>animation-timing-function：规定动画的速度曲线。默认是ease</li><li>animation-delay：规定动画何时开始。默认是 0</li><li>animation-iteration-count：规定动画被播放的次数。默认是 1</li><li>animation-direction：规定动画是否在下一周期逆向地播放。默认是normal</li><li>animation-play-state ：规定动画是否正在运行或暂停。默认是running</li><li>animation-fill-mode：规定动画执行之前和之后如何给动画的目标应用，默认是none，保留在最后一帧可以用forwards</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础巩固</category>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
